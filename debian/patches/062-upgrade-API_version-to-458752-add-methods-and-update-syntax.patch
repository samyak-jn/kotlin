Description: Upgrade API_Version and update syntax accordingly in compiler
 This patch does the following things:
 Opcodes.API_VERSION ~> 458752, Corrects Syntax.
 Convert javaslang.Tuple2 to io.vavr.Tuple2
Author: Saif Abdul Casim

---

--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/AbstractClassBuilder.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/AbstractClassBuilder.java
@@ -31,8 +31,8 @@
 import static org.jetbrains.kotlin.codegen.inline.InlineCodegenUtilsKt.GENERATE_SMAP;
 
 public abstract class AbstractClassBuilder implements ClassBuilder {
-    protected static final MethodVisitor EMPTY_METHOD_VISITOR = new MethodVisitor(Opcodes.API_VERSION) {};
-    protected static final FieldVisitor EMPTY_FIELD_VISITOR = new FieldVisitor(Opcodes.API_VERSION) {};
+    protected static final MethodVisitor EMPTY_METHOD_VISITOR = new MethodVisitor(458752) {};
+    protected static final FieldVisitor EMPTY_FIELD_VISITOR = new FieldVisitor(458752) {};
 
     private String thisName;
 
@@ -76,14 +76,13 @@
     }
 
     @Override
-    @NotNull
     public MethodVisitor newMethod(
-            @NotNull JvmDeclarationOrigin origin,
+            JvmDeclarationOrigin origin,
             int access,
-            @NotNull String name,
-            @NotNull String desc,
-            @Nullable String signature,
-            @Nullable String[] exceptions
+            String name,
+            String desc,
+            String signature,
+            String[] exceptions
     ) {
         MethodVisitor visitor = getVisitor().visitMethod(access, name, desc, signature, exceptions);
         if (visitor == null) {
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/AnnotationCodegen.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/AnnotationCodegen.java
@@ -72,7 +72,7 @@
             new JvmFlagAnnotation(JvmAnnotationUtilKt.SYNCHRONIZED_ANNOTATION_FQ_NAME.asString(), Opcodes.ACC_SYNCHRONIZED)
     );
 
-    private static final AnnotationVisitor NO_ANNOTATION_VISITOR = new AnnotationVisitor(Opcodes.API_VERSION) {
+    private static final AnnotationVisitor NO_ANNOTATION_VISITOR = new AnnotationVisitor(458752) {
         @Override
         public AnnotationVisitor visitAnnotation(String name, @NotNull String desc) {
             return safe(super.visitAnnotation(name, desc));
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/AsmUtil.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/AsmUtil.java
@@ -74,7 +74,7 @@
 
 public class AsmUtil {
 
-    public static final boolean IS_BUILT_WITH_ASM6 = Opcodes.API_VERSION <= Opcodes.ASM6;
+    public static final boolean IS_BUILT_WITH_ASM6 = 458752 <= Opcodes.ASM6;
 
     private static final Set<Type> STRING_BUILDER_OBJECT_APPEND_ARG_TYPES = Sets.newHashSet(
             getType(String.class),
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/AssertCodegenUtil.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/AssertCodegenUtil.kt
@@ -58,7 +58,7 @@
 
     val node =
         org.jetbrains.org.objectweb.asm.tree.MethodNode(
-            Opcodes.API_VERSION,
+            458752,
             Opcodes.ACC_STATIC,
             "fake",
             typeMapper.mapAsmMethod(functionDescriptor).descriptor, null, null
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/CallGenerator.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/CallGenerator.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
+ * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
  * that can be found in the license/LICENSE.txt file.
  */
 
@@ -18,7 +18,9 @@
     DEFAULT_MASK,
     METHOD_HANDLE_IN_DEFAULT,
     CAPTURED,
-    DEFAULT_LAMBDA_CAPTURED_PARAMETER
+    DEFAULT_LAMBDA_CAPTURED_PARAMETER,
+    NON_INLINEABLE_ARGUMENT_FOR_INLINE_PARAMETER_CALLED_IN_SUSPEND,
+    NON_INLINEABLE_ARGUMENT_FOR_INLINE_SUSPEND_PARAMETER
 }
 
 interface CallGenerator {
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/ClassBuilder.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/ClassBuilder.java
@@ -38,14 +38,13 @@
             @Nullable Object value
     );
 
-    @NotNull
     MethodVisitor newMethod(
-            @NotNull JvmDeclarationOrigin origin,
+            JvmDeclarationOrigin origin,
             int access,
-            @NotNull String name,
-            @NotNull String desc,
-            @Nullable String signature,
-            @Nullable String[] exceptions
+            String name,
+            String desc,
+            String signature,
+            String[] exceptions
     );
 
     @NotNull
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/DelegatingClassBuilder.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/DelegatingClassBuilder.java
@@ -44,15 +44,14 @@
         return getDelegate().newField(origin, access, name, desc, signature, value);
     }
 
-    @NotNull
     @Override
     public MethodVisitor newMethod(
-            @NotNull JvmDeclarationOrigin origin,
+            JvmDeclarationOrigin origin,
             int access,
-            @NotNull String name,
-            @NotNull String desc,
-            @Nullable String signature,
-            @Nullable String[] exceptions
+            String name,
+            String desc,
+            String signature,
+            String[] exceptions
     ) {
         return getDelegate().newMethod(origin, access, name, desc, signature, exceptions);
     }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/FunctionCodegen.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/FunctionCodegen.java
@@ -14,6 +14,7 @@
 import org.jetbrains.annotations.Nullable;
 import org.jetbrains.kotlin.backend.common.CodegenUtil;
 import org.jetbrains.kotlin.backend.common.bridges.Bridge;
+import org.jetbrains.kotlin.codegen.binding.CalculatedClosure;
 import org.jetbrains.kotlin.codegen.binding.CodegenBinding;
 import org.jetbrains.kotlin.codegen.context.*;
 import org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenUtilKt;
@@ -125,7 +126,8 @@
                             CoroutineCodegenUtilKt.<FunctionDescriptor>unwrapInitialDescriptorForSuspendFunction(functionDescriptor),
                             function,
                             v.getThisName(),
-                            state.getConstructorCallNormalizationMode()
+                            state.getConstructorCallNormalizationMode(),
+                            this
                     );
                 } else {
                     strategy = new SuspendInlineFunctionGenerationStrategy(
@@ -1690,4 +1692,9 @@
             }
         }
     }
+
+    @Nullable
+    public CalculatedClosure getClosure() {
+        return owner.closure;
+    }
 }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/TransformationMethodVisitor.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/TransformationMethodVisitor.kt
@@ -34,7 +34,7 @@
     desc: String,
     signature: String?,
     exceptions: Array<out String>?,
-    api: Int = Opcodes.API_VERSION
+    api: Int = 458752
 ) : MethodVisitor(api) {
 
     private val methodNode = MethodNode(access, name, desc, signature, exceptions).apply {
@@ -70,7 +70,7 @@
                 performTransformations(methodNode)
             }
 
-            methodNode.accept(EndIgnoringMethodVisitorDecorator(Opcodes.API_VERSION, delegate))
+            methodNode.accept(EndIgnoringMethodVisitorDecorator(458752, delegate))
 
 
             // In case of empty instructions list MethodNode.accept doesn't call visitLocalVariables of delegate
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/binding/CodegenAnnotatingVisitor.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/binding/CodegenAnnotatingVisitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
+ * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
  * that can be found in the license/LICENSE.txt file.
  */
 
@@ -726,6 +726,9 @@
             if (variableDescriptor instanceof ValueParameterDescriptor &&
                 ((ValueParameterDescriptor) variableDescriptor).isCrossinline()) {
                 DeclarationDescriptor functionWithCrossinlineParameter = variableDescriptor.getContainingDeclaration();
+                if (functionsStack.peek().isSuspend()) {
+                    bindingTrace.record(CALL_SITE_IS_SUSPEND_FOR_CROSSINLINE_LAMBDA, (ValueParameterDescriptor) variableDescriptor, true);
+                }
                 for (int i = functionsStack.size() - 1; i >= 0; i--) {
                     Boolean alreadyPutValue = bindingTrace.getBindingContext()
                             .get(CodegenBinding.CAPTURES_CROSSINLINE_LAMBDA, functionsStack.get(i));
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/binding/CodegenBinding.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/binding/CodegenBinding.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
+ * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
  * that can be found in the license/LICENSE.txt file.
  */
 
@@ -60,6 +60,9 @@
     public static final WritableSlice<FunctionDescriptor, Boolean> CAPTURES_CROSSINLINE_LAMBDA =
             Slices.createSimpleSlice();
 
+    public static final WritableSlice<ValueParameterDescriptor, Boolean> CALL_SITE_IS_SUSPEND_FOR_CROSSINLINE_LAMBDA =
+            Slices.createSimpleSlice();
+
     public static final WritableSlice<ClassDescriptor, Boolean> RECURSIVE_SUSPEND_CALLABLE_REFERENCE =
             Slices.createSimpleSlice();
 
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/CoroutineCodegen.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/CoroutineCodegen.kt
@@ -1,16 +1,20 @@
 /*
- * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
+ * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
  * that can be found in the license/LICENSE.txt file.
  */
 
 package org.jetbrains.kotlin.codegen.coroutines
 
 import com.intellij.util.ArrayUtil
+import org.jetbrains.kotlin.builtins.isSuspendFunctionTypeOrSubtype
 import org.jetbrains.kotlin.codegen.*
+import org.jetbrains.kotlin.codegen.binding.CalculatedClosure
 import org.jetbrains.kotlin.codegen.binding.CodegenBinding
 import org.jetbrains.kotlin.codegen.binding.CodegenBinding.CAPTURES_CROSSINLINE_LAMBDA
+import org.jetbrains.kotlin.codegen.binding.CodegenBinding.CLOSURE
 import org.jetbrains.kotlin.codegen.context.ClosureContext
 import org.jetbrains.kotlin.codegen.context.MethodContext
+import org.jetbrains.kotlin.codegen.inline.coroutines.SurroundSuspendLambdaCallsWithSuspendMarkersMethodVisitor
 import org.jetbrains.kotlin.codegen.serialization.JvmSerializationBindings.METHOD_FOR_FUNCTION
 import org.jetbrains.kotlin.codegen.serialization.JvmSerializerExtension
 import org.jetbrains.kotlin.config.LanguageFeature
@@ -22,10 +26,8 @@
 import org.jetbrains.kotlin.incremental.components.NoLookupLocation
 import org.jetbrains.kotlin.load.kotlin.header.KotlinClassHeader
 import org.jetbrains.kotlin.name.Name
-import org.jetbrains.kotlin.psi.KtCallableReferenceExpression
-import org.jetbrains.kotlin.psi.KtDeclarationWithBody
-import org.jetbrains.kotlin.psi.KtElement
-import org.jetbrains.kotlin.psi.KtFunction
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.BindingContext
 import org.jetbrains.kotlin.resolve.DescriptorUtils
 import org.jetbrains.kotlin.resolve.descriptorUtil.builtIns
 import org.jetbrains.kotlin.resolve.descriptorUtil.module
@@ -38,11 +40,13 @@
 import org.jetbrains.kotlin.types.typeUtil.makeNullable
 import org.jetbrains.kotlin.utils.addToStdlib.safeAs
 import org.jetbrains.kotlin.utils.sure
+import org.jetbrains.org.objectweb.asm.Label
 import org.jetbrains.org.objectweb.asm.MethodVisitor
 import org.jetbrains.org.objectweb.asm.Opcodes
 import org.jetbrains.org.objectweb.asm.Type
 import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter
 import org.jetbrains.org.objectweb.asm.commons.Method
+import org.jetbrains.org.objectweb.asm.tree.MethodNode
 
 abstract class AbstractCoroutineCodegen(
     outerExpressionCodegen: ExpressionCodegen,
@@ -452,8 +456,7 @@
             object : FunctionGenerationStrategy.FunctionDefault(state, element as KtDeclarationWithBody) {
 
                 override fun wrapMethodVisitor(mv: MethodVisitor, access: Int, name: String, desc: String): MethodVisitor {
-                    if (forInline) return super.wrapMethodVisitor(mv, access, name, desc)
-                    return CoroutineTransformerMethodVisitor(
+                    val stateMachineBuilder = CoroutineTransformerMethodVisitor(
                         mv, access, name, desc, null, null,
                         obtainClassBuilderForCoroutineState = { v },
                         element = element,
@@ -464,6 +467,17 @@
                         languageVersionSettings = languageVersionSettings,
                         sourceFile = element.containingFile.name
                     )
+                    return if (forInline) AddEndLabelMethodVisitor(
+                        MethodNodeCopyingMethodVisitor(
+                            SurroundSuspendLambdaCallsWithSuspendMarkersMethodVisitor(
+                                stateMachineBuilder, access, name, desc, v.thisName,
+                                isCapturedSuspendLambda = { isCapturedSuspendLambda(closure, it.name, state.bindingContext) }
+                            ), access, name, desc,
+                            newMethod = { origin, newAccess, newName, newDesc ->
+                                functionCodegen.newMethod(origin, newAccess, newName, newDesc, null, null)
+                            }
+                        ), access, name, desc, Label()
+                    ) else AddEndLabelMethodVisitor(stateMachineBuilder, access, name, desc, Label())
                 }
 
                 override fun doGenerateBody(codegen: ExpressionCodegen, signature: JvmMethodSignature) {
@@ -503,6 +517,37 @@
     }
 }
 
+fun isCapturedSuspendLambda(closure: CalculatedClosure, name: String, bindingContext: BindingContext): Boolean {
+    for ((param, value) in closure.captureVariables) {
+        if (param !is ValueParameterDescriptor) continue
+        if (value.fieldName != name) continue
+        return param.type.isSuspendFunctionTypeOrSubtype
+    }
+    val classDescriptor = closure.capturedOuterClassDescriptor ?: return false
+    return isCapturedSuspendLambda(classDescriptor, name, bindingContext)
+}
+
+fun isCapturedSuspendLambda(classDescriptor: ClassDescriptor, name: String, bindingContext: BindingContext): Boolean {
+    val closure = bindingContext[CLOSURE, classDescriptor] ?: return false
+    return isCapturedSuspendLambda(closure, name, bindingContext)
+}
+
+private class AddEndLabelMethodVisitor(
+    delegate: MethodVisitor,
+    access: Int,
+    name: String,
+    desc: String,
+    private val endLabel: Label
+) : TransformationMethodVisitor(delegate, access, name, desc, null, null) {
+    override fun performTransformations(methodNode: MethodNode) {
+        methodNode.instructions.add(
+            withInstructionAdapter {
+                mark(endLabel)
+            }
+        )
+    }
+}
+
 class CoroutineCodegenForNamedFunction private constructor(
     outerExpressionCodegen: ExpressionCodegen,
     element: KtElement,
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/CoroutineTransformerMethodVisitor.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/CoroutineTransformerMethodVisitor.kt
@@ -47,6 +47,8 @@
 private const val COROUTINES_METADATA_VERSION_JVM_NAME = "v"
 
 const val SUSPEND_FUNCTION_CONTINUATION_PARAMETER = "\$completion"
+const val SUSPEND_CALL_RESULT_NAME = "\$result"
+const val ILLEGAL_STATE_ERROR_MESSAGE = "call to 'resume' before 'invoke' with coroutine"
 
 class CoroutineTransformerMethodVisitor(
     delegate: MethodVisitor,
@@ -177,7 +179,7 @@
             insert(last, defaultLabel)
 
             insert(last, withInstructionAdapter {
-                AsmUtil.genThrow(this, "java/lang/IllegalStateException", "call to 'resume' before 'invoke' with coroutine")
+                AsmUtil.genThrow(this, "java/lang/IllegalStateException", ILLEGAL_STATE_ERROR_MESSAGE)
                 areturn(Type.VOID_TYPE)
             })
         }
@@ -377,8 +379,8 @@
         methodNode.instructions.resetLabels()
         methodNode.accept(
             MaxStackFrameSizeAndLocalsCalculator(
-                Opcodes.API_VERSION, methodNode.access, methodNode.desc,
-                object : MethodVisitor(Opcodes.API_VERSION) {
+                458752, methodNode.access, methodNode.desc,
+                object : MethodVisitor(458752) {
                     override fun visitMaxs(maxStack: Int, maxLocals: Int) {
                         methodNode.maxStack = maxStack
                     }
@@ -954,7 +956,7 @@
     }
 }
 
-internal class IgnoringCopyOperationSourceInterpreter : SourceInterpreter(Opcodes.API_VERSION) {
+internal class IgnoringCopyOperationSourceInterpreter : SourceInterpreter(458752) {
     override fun copyOperation(insn: AbstractInsnNode?, value: SourceValue?) = value
 }
 
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/SuspendFunctionGenerationStrategy.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/SuspendFunctionGenerationStrategy.kt
@@ -5,12 +5,10 @@
 
 package org.jetbrains.kotlin.codegen.coroutines
 
-import org.jetbrains.kotlin.codegen.ClassBuilder
-import org.jetbrains.kotlin.codegen.ExpressionCodegen
-import org.jetbrains.kotlin.codegen.FunctionGenerationStrategy
-import org.jetbrains.kotlin.codegen.TransformationMethodVisitor
+import org.jetbrains.kotlin.codegen.*
 import org.jetbrains.kotlin.codegen.binding.CodegenBinding
 import org.jetbrains.kotlin.codegen.inline.addFakeContinuationConstructorCallMarker
+import org.jetbrains.kotlin.codegen.inline.coroutines.SurroundSuspendLambdaCallsWithSuspendMarkersMethodVisitor
 import org.jetbrains.kotlin.codegen.state.GenerationState
 import org.jetbrains.kotlin.config.JVMConstructorCallNormalizationMode
 import org.jetbrains.kotlin.config.LanguageVersionSettings
@@ -22,17 +20,19 @@
 import org.jetbrains.kotlin.resolve.jvm.diagnostics.OtherOrigin
 import org.jetbrains.kotlin.resolve.jvm.jvmSignature.JvmMethodSignature
 import org.jetbrains.kotlin.utils.addToStdlib.safeAs
+import org.jetbrains.kotlin.utils.sure
 import org.jetbrains.org.objectweb.asm.MethodVisitor
 import org.jetbrains.org.objectweb.asm.Opcodes
 import org.jetbrains.org.objectweb.asm.Type
 import org.jetbrains.org.objectweb.asm.tree.MethodNode
 
 open class SuspendFunctionGenerationStrategy(
-        state: GenerationState,
-        protected val originalSuspendDescriptor: FunctionDescriptor,
-        protected val declaration: KtFunction,
-        private val containingClassInternalName: String,
-        private val constructorCallNormalizationMode: JVMConstructorCallNormalizationMode
+    state: GenerationState,
+    protected val originalSuspendDescriptor: FunctionDescriptor,
+    protected val declaration: KtFunction,
+    private val containingClassInternalName: String,
+    private val constructorCallNormalizationMode: JVMConstructorCallNormalizationMode,
+    protected val functionCodegen: FunctionCodegen
 ) : FunctionGenerationStrategy.CodegenBased(state) {
 
     private lateinit var codegen: ExpressionCodegen
@@ -45,7 +45,7 @@
             declaration.containingFile
         ).also {
             val coroutineCodegen =
-                    CoroutineCodegenForNamedFunction.create(it, codegen, originalSuspendDescriptor, declaration)
+                CoroutineCodegenForNamedFunction.create(it, codegen, originalSuspendDescriptor, declaration)
             coroutineCodegen.generate()
         }
     }
@@ -53,16 +53,7 @@
     override fun wrapMethodVisitor(mv: MethodVisitor, access: Int, name: String, desc: String): MethodVisitor {
         if (access and Opcodes.ACC_ABSTRACT != 0) return mv
 
-        if (state.bindingContext[CodegenBinding.CAPTURES_CROSSINLINE_LAMBDA, originalSuspendDescriptor] == true) {
-            return AddConstructorCallForCoroutineRegeneration(
-                mv, access, name, desc, null, null, this::classBuilderForCoroutineState,
-                containingClassInternalName,
-                originalSuspendDescriptor.dispatchReceiverParameter != null,
-                containingClassInternalNameOrNull(),
-                languageVersionSettings
-            )
-        }
-        return CoroutineTransformerMethodVisitor(
+        val stateMachineBuilder = CoroutineTransformerMethodVisitor(
             mv, access, name, desc, null, null, containingClassInternalName, this::classBuilderForCoroutineState,
             isForNamedFunction = true,
             element = declaration,
@@ -73,10 +64,40 @@
             languageVersionSettings = languageVersionSettings,
             sourceFile = declaration.containingFile.name
         )
+
+        val forInline = state.bindingContext[CodegenBinding.CAPTURES_CROSSINLINE_LAMBDA, originalSuspendDescriptor] == true
+        // Both capturing and inline functions share the same suffix, however, inline functions can also be capturing
+        // they are already covered by SuspendInlineFunctionGenerationStrategy, thus, if we generate yet another copy,
+        // we will get name+descriptor clash
+        return if (forInline && !originalSuspendDescriptor.isInline)
+            AddConstructorCallForCoroutineRegeneration(
+                MethodNodeCopyingMethodVisitor(
+                    SurroundSuspendLambdaCallsWithSuspendMarkersMethodVisitor(
+                        stateMachineBuilder,
+                        access, name, desc, containingClassInternalName,
+                        isCapturedSuspendLambda = {
+                            isCapturedSuspendLambda(
+                                functionCodegen.closure.sure {
+                                    "Anonymous object should have closure"
+                                },
+                                it.name,
+                                state.bindingContext
+                            )
+                        }
+                    ), access, name, desc,
+                    newMethod = { origin, newAccess, newName, newDesc ->
+                        functionCodegen.newMethod(origin, newAccess, newName, newDesc, null, null)
+                    }
+                ), access, name, desc, null, null, this::classBuilderForCoroutineState,
+                containingClassInternalName,
+                originalSuspendDescriptor.dispatchReceiverParameter != null,
+                containingClassInternalNameOrNull(),
+                languageVersionSettings
+            ) else stateMachineBuilder
     }
 
     private fun containingClassInternalNameOrNull() =
-            originalSuspendDescriptor.containingDeclaration.safeAs<ClassDescriptor>()?.let(state.typeMapper::mapClass)?.internalName
+        originalSuspendDescriptor.containingDeclaration.safeAs<ClassDescriptor>()?.let(state.typeMapper::mapClass)?.internalName
 
     override fun doGenerateBody(codegen: ExpressionCodegen, signature: JvmMethodSignature) {
         this.codegen = codegen
@@ -116,6 +137,7 @@
                     languageVersionSettings
                 )
                 addFakeContinuationConstructorCallMarker(this, false)
+                pop() // Otherwise stack-transformation breaks
             })
         }
     }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/SuspendInlineFunctionGenerationStrategy.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/SuspendInlineFunctionGenerationStrategy.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
+ * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
  * that can be found in the license/LICENSE.txt file.
  */
 
@@ -9,12 +9,12 @@
 import org.jetbrains.kotlin.codegen.FunctionCodegen
 import org.jetbrains.kotlin.codegen.FunctionGenerationStrategy
 import org.jetbrains.kotlin.codegen.TransformationMethodVisitor
+import org.jetbrains.kotlin.codegen.inline.coroutines.FOR_INLINE_SUFFIX
 import org.jetbrains.kotlin.codegen.state.GenerationState
 import org.jetbrains.kotlin.config.JVMConstructorCallNormalizationMode
-import org.jetbrains.kotlin.config.LanguageFeature
 import org.jetbrains.kotlin.descriptors.FunctionDescriptor
 import org.jetbrains.kotlin.psi.KtFunction
-import org.jetbrains.kotlin.resolve.jvm.diagnostics.OtherOrigin
+import org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin
 import org.jetbrains.kotlin.resolve.jvm.jvmSignature.JvmMethodSignature
 import org.jetbrains.org.objectweb.asm.MethodVisitor
 import org.jetbrains.org.objectweb.asm.Opcodes
@@ -29,13 +29,14 @@
     declaration: KtFunction,
     containingClassInternalName: String,
     constructorCallNormalizationMode: JVMConstructorCallNormalizationMode,
-    private val codegen: FunctionCodegen
+    codegen: FunctionCodegen
 ) : SuspendFunctionGenerationStrategy(
     state,
     originalSuspendDescriptor,
     declaration,
     containingClassInternalName,
-    constructorCallNormalizationMode
+    constructorCallNormalizationMode,
+    codegen
 ) {
     private val defaultStrategy = FunctionGenerationStrategy.FunctionDefault(state, declaration)
 
@@ -43,16 +44,10 @@
         if (access and Opcodes.ACC_ABSTRACT != 0) return mv
 
         return MethodNodeCopyingMethodVisitor(
-            super.wrapMethodVisitor(mv, access, name, desc),
-            access,
-            name,
-            desc = desc,
-            signature = null,
-            exceptions = null,
-            codegen = codegen,
-            declaration = declaration,
-            originalSuspendDescriptor = originalSuspendDescriptor,
-            isReleaseCoroutines = state.languageVersionSettings.supportsFeature(LanguageFeature.ReleaseCoroutines)
+            super.wrapMethodVisitor(mv, access, name, desc), access, name, desc,
+            newMethod = { origin, newAccess, newName, newDesc ->
+                functionCodegen.newMethod(origin, newAccess, newName, newDesc, null, null)
+            }, keepAccess = false
         )
     }
 
@@ -60,46 +55,26 @@
         super.doGenerateBody(codegen, signature)
         defaultStrategy.doGenerateBody(codegen, signature)
     }
+}
 
-    private class MethodNodeCopyingMethodVisitor(
-        delegate: MethodVisitor,
-        private val access: Int,
-        private val name: String,
-        private val desc: String,
-        private val signature: String?,
-        private val exceptions: Array<out String>?,
-        private val codegen: FunctionCodegen,
-        private val declaration: KtFunction,
-        private val originalSuspendDescriptor: FunctionDescriptor,
-        private val isReleaseCoroutines: Boolean
-    ) : TransformationMethodVisitor(
-        delegate,
-        calculateAccessForInline(access),
-        "$name\$\$forInline",
-        desc,
-        signature,
-        exceptions
-    ) {
-        override fun performTransformations(methodNode: MethodNode) {
-            val newMethodNode = codegen.newMethod(
-                OtherOrigin(declaration, getOrCreateJvmSuspendFunctionView(originalSuspendDescriptor, isReleaseCoroutines)),
-                calculateAccessForInline(access), "$name\$\$forInline", desc, signature, exceptions
-            )
-            methodNode.instructions.resetLabels()
-            methodNode.accept(newMethodNode)
-        }
+class MethodNodeCopyingMethodVisitor(
+    delegate: MethodVisitor, private val access: Int, private val name: String, private val desc: String,
+    private val newMethod: (JvmDeclarationOrigin, Int, String, String) -> MethodVisitor,
+    private val keepAccess: Boolean = true
+) : TransformationMethodVisitor(
+    delegate, calculateAccessForInline(access, keepAccess), "$name$FOR_INLINE_SUFFIX", desc, null, null
+) {
+    override fun performTransformations(methodNode: MethodNode) {
+        val newMethodNode = newMethod(
+            JvmDeclarationOrigin.NO_ORIGIN, calculateAccessForInline(access, keepAccess), "$name$FOR_INLINE_SUFFIX", desc
+        )
+        methodNode.instructions.resetLabels()
+        methodNode.accept(newMethodNode)
     }
 
     companion object {
-        private fun calculateAccessForInline(access: Int): Int {
-            var accessForInline = access
-            if (accessForInline and Opcodes.ACC_PUBLIC != 0) {
-                accessForInline = accessForInline xor Opcodes.ACC_PUBLIC
-            }
-            if (accessForInline and Opcodes.ACC_PROTECTED != 0) {
-                accessForInline = accessForInline xor Opcodes.ACC_PROTECTED
-            }
-            return accessForInline or Opcodes.ACC_PRIVATE
-        }
+        private fun calculateAccessForInline(access: Int, keepAccess: Boolean): Int =
+            if (keepAccess) access
+            else access or Opcodes.ACC_PRIVATE and Opcodes.ACC_PUBLIC.inv() and Opcodes.ACC_PROTECTED.inv()
     }
-}
\ No newline at end of file
+}
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/coroutineCodegenUtil.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/coroutineCodegenUtil.kt
@@ -342,7 +342,7 @@
 
     val node =
         MethodNode(
-            Opcodes.API_VERSION,
+            458752,
             Opcodes.ACC_STATIC,
             "fake",
             typeMapper.mapAsmMethod(functionDescriptor).descriptor, null, null
@@ -368,7 +368,7 @@
 
     val node =
         MethodNode(
-            Opcodes.API_VERSION,
+            458752,
             Opcodes.ACC_STATIC,
             "fake",
             Type.getMethodDescriptor(languageVersionSettings.coroutineContextAsmType()),
@@ -397,7 +397,7 @@
 
     val node =
         MethodNode(
-            Opcodes.API_VERSION,
+            458752,
             Opcodes.ACC_STATIC,
             "fake",
             typeMapper.mapAsmMethod(functionDescriptor).descriptor, null, null
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/refinedIntTypesAnalysis.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/refinedIntTypesAnalysis.kt
@@ -169,7 +169,7 @@
     }
 }
 
-private class MySourceInterpreter : SourceInterpreter(Opcodes.API_VERSION) {
+private class MySourceInterpreter : SourceInterpreter(458752) {
     override fun copyOperation(insn: AbstractInsnNode, value: SourceValue) =
             when {
                 insn.isStoreOperation() || insn.isLoadOperation() -> SourceValue(value.size, insn)
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/AnonymousObjectTransformer.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/AnonymousObjectTransformer.kt
@@ -7,6 +7,8 @@
 
 import com.intellij.util.ArrayUtil
 import org.jetbrains.kotlin.codegen.*
+import org.jetbrains.kotlin.codegen.coroutines.DEBUG_METADATA_ANNOTATION_ASM_TYPE
+import org.jetbrains.kotlin.codegen.coroutines.isCapturedSuspendLambda
 import org.jetbrains.kotlin.codegen.coroutines.isCoroutineSuperClass
 import org.jetbrains.kotlin.codegen.inline.coroutines.CoroutineTransformer
 import org.jetbrains.kotlin.codegen.serialization.JvmCodegenStringTable
@@ -49,7 +51,7 @@
         val metadataReader = ReadKotlinClassHeaderAnnotationVisitor()
         lateinit var superClassName: String
 
-        createClassReader().accept(object : ClassVisitor(Opcodes.API_VERSION, classBuilder.visitor) {
+        createClassReader().accept(object : ClassVisitor(458752, classBuilder.visitor) {
             override fun visit(version: Int, access: Int, name: String, signature: String?, superName: String, interfaces: Array<String>) {
                 classBuilder.defineClass(null, version, access, name, signature, superName, interfaces)
                 if (languageVersionSettings.isCoroutineSuperClass(superName)) {
@@ -67,6 +69,8 @@
                     // Empty inner class info because no inner classes are used in kotlin.Metadata and its arguments
                     val innerClassesInfo = FileBasedKotlinClass.InnerClassesInfo()
                     return FileBasedKotlinClass.convertAnnotationVisitor(metadataReader, desc, innerClassesInfo)
+                } else if (desc == DEBUG_METADATA_ANNOTATION_ASM_TYPE.descriptor) {
+                    return null
                 }
                 return super.visitAnnotation(desc, visible)
             }
@@ -134,12 +138,14 @@
             inliningContext,
             classBuilder,
             methodsToTransform,
-            superClassName
+            superClassName,
+            allCapturedParamBuilder.listCaptured()
         )
-        for (next in methodsToTransform) {
+        loop@for (next in methodsToTransform) {
             val deferringVisitor =
                 when {
-                    coroutineTransformer.shouldTransform(next) -> coroutineTransformer.newMethod(next)
+                    coroutineTransformer.shouldSkip(next) -> continue@loop
+                    coroutineTransformer.shouldGenerateStateMachine(next) -> coroutineTransformer.newMethod(next)
                     else -> newMethod(classBuilder, next)
                 }
             val funResult = inlineMethodAndUpdateGlobalResult(parentRemapper, deferringVisitor, next, allCapturedParamBuilder, false)
@@ -275,7 +281,8 @@
             InlineCallSiteInfo(
                 transformationInfo.oldClassName,
                 sourceNode.name,
-                if (isConstructor) transformationInfo.newConstructorDescriptor else sourceNode.desc
+                if (isConstructor) transformationInfo.newConstructorDescriptor else sourceNode.desc,
+                inliningContext.callSiteInfo.isInlineOrInsideInline
             ), null
         )
 
@@ -341,7 +348,7 @@
         for (info in constructorAdditionalFakeParams) {
             val fake = constructorInlineBuilder.addCapturedParamCopy(info)
 
-            if (fake.lambda != null) {
+            if (fake.functionalArgument is LambdaInfo) {
                 //set remap value to skip this fake (captured with lambda already skipped)
                 val composed = StackValue.field(
                     fake.getType(),
@@ -413,7 +420,7 @@
     ): List<CapturedParamInfo> {
         val capturedLambdas = LinkedHashSet<LambdaInfo>() //captured var of inlined parameter
         val constructorAdditionalFakeParams = ArrayList<CapturedParamInfo>()
-        val indexToLambda = transformationInfo.lambdasToInline
+        val indexToFunctionalArgument = transformationInfo.functionalArguments
         val capturedParams = HashSet<Int>()
 
         //load captured parameters and patch instruction list
@@ -423,18 +430,18 @@
             val fieldName = fieldNode.name
             val parameterAload = fieldNode.previous as VarInsnNode
             val varIndex = parameterAload.`var`
-            val lambdaInfo = indexToLambda[varIndex]
-            val newFieldName = if (isThis0(fieldName) && shouldRenameThis0(parentFieldRemapper, indexToLambda.values))
+            val functionalArgument = indexToFunctionalArgument[varIndex]
+            val newFieldName = if (isThis0(fieldName) && shouldRenameThis0(parentFieldRemapper, indexToFunctionalArgument.values))
                 getNewFieldName(fieldName, true)
             else
                 fieldName
             val info = capturedParamBuilder.addCapturedParam(
                 Type.getObjectType(transformationInfo.oldClassName), fieldName, newFieldName,
-                Type.getType(fieldNode.desc), lambdaInfo != null, null
+                Type.getType(fieldNode.desc), functionalArgument is LambdaInfo, null
             )
-            if (lambdaInfo != null) {
-                info.lambda = lambdaInfo
-                capturedLambdas.add(lambdaInfo)
+            info.functionalArgument = functionalArgument
+            if (functionalArgument is LambdaInfo) {
+                capturedLambdas.add(functionalArgument)
             }
             constructorAdditionalFakeParams.add(info)
             capturedParams.add(varIndex)
@@ -449,9 +456,9 @@
 
         val paramTypes = transformationInfo.constructorDesc?.let { Type.getArgumentTypes(it) } ?: emptyArray()
         for (type in paramTypes) {
-            val info = indexToLambda[constructorParamBuilder.nextParameterOffset]
-            val parameterInfo = constructorParamBuilder.addNextParameter(type, info != null)
-            parameterInfo.lambda = info
+            val info = indexToFunctionalArgument[constructorParamBuilder.nextParameterOffset]
+            val parameterInfo = constructorParamBuilder.addNextParameter(type, info is LambdaInfo)
+            parameterInfo.functionalArgument = info
             if (capturedParams.contains(parameterInfo.index)) {
                 parameterInfo.isCaptured = true
             } else {
@@ -477,6 +484,11 @@
                         alreadyAddedParam?.newFieldName ?: getNewFieldName(desc.fieldName, false),
                         alreadyAddedParam != null
                     )
+                    if (info is PsiExpressionLambda && info.closure.captureVariables.any { it.value.fieldName == desc.fieldName }) {
+                        recapturedParamInfo.functionalArgument = NonInlineableArgumentForInlineableParameterCalledInSuspend(
+                            isCapturedSuspendLambda(info.closure, desc.fieldName, inliningContext.state.bindingContext)
+                        )
+                    }
                     val composed = StackValue.field(
                         desc.type,
                         oldObjectType, /*TODO owner type*/
@@ -517,9 +529,9 @@
         return constructorAdditionalFakeParams
     }
 
-    private fun shouldRenameThis0(parentFieldRemapper: FieldRemapper, values: Collection<LambdaInfo>): Boolean {
+    private fun shouldRenameThis0(parentFieldRemapper: FieldRemapper, values: Collection<FunctionalArgument>): Boolean {
         return if (isFirstDeclSiteLambdaFieldRemapper(parentFieldRemapper)) {
-            values.any { it.capturedVars.any { isThis0(it.fieldName) } }
+            values.any { it is LambdaInfo && it.capturedVars.any { isThis0(it.fieldName) } }
         } else false
     }
 
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/CapturedParamInfo.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/CapturedParamInfo.java
@@ -65,7 +65,7 @@
         CapturedParamInfo result = new CapturedParamInfo(
                 desc, newFieldName, isSkipped, getIndex(), getRemapValue(), skipInConstructor, newDeclarationIndex
         );
-        result.setLambda(getLambda());
+        result.setFunctionalArgument(getFunctionalArgument());
         result.setSynthetic(synthetic);
         return result;
     }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/DeferredMethodVisitor.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/DeferredMethodVisitor.kt
@@ -23,7 +23,7 @@
 class DeferredMethodVisitor(
     val intermediate: MethodNode,
     private val resultNode: () -> MethodVisitor
-) : MethodVisitor(Opcodes.API_VERSION, intermediate) {
+) : MethodVisitor(458752, intermediate) {
 
     override fun visitEnd() {
         super.visitEnd()
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InlineAdapter.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InlineAdapter.java
@@ -38,7 +38,7 @@
     private int nextLocalIndexBeforeInline = -1;
 
     public InlineAdapter(@NotNull MethodVisitor mv, int localsSize, @NotNull SourceMapper sourceMapper) {
-        super(Opcodes.API_VERSION, mv);
+        super(458752, mv);
         this.nextLocalIndex = localsSize;
         this.sourceMapper = sourceMapper;
     }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InlineCallSiteInfo.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InlineCallSiteInfo.kt
@@ -16,4 +16,4 @@
 
 package org.jetbrains.kotlin.codegen.inline
 
-class InlineCallSiteInfo(val ownerClassName: String, val functionName: String?, val functionDesc: String?)
\ No newline at end of file
+class InlineCallSiteInfo(val ownerClassName: String, val functionName: String?, val functionDesc: String?, val isInlineOrInsideInline: Boolean)
\ No newline at end of file
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InlineCodegen.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InlineCodegen.kt
@@ -9,9 +9,12 @@
 import com.intellij.util.ArrayUtil
 import org.jetbrains.kotlin.backend.common.isBuiltInIntercepted
 import org.jetbrains.kotlin.builtins.BuiltInsPackageFragment
+import org.jetbrains.kotlin.builtins.KotlinBuiltIns
+import org.jetbrains.kotlin.builtins.isSuspendFunctionTypeOrSubtype
 import org.jetbrains.kotlin.codegen.*
 import org.jetbrains.kotlin.codegen.AsmUtil.getMethodAsmFlags
 import org.jetbrains.kotlin.codegen.AsmUtil.isPrimitive
+import org.jetbrains.kotlin.codegen.binding.CodegenBinding
 import org.jetbrains.kotlin.codegen.context.ClosureContext
 import org.jetbrains.kotlin.codegen.coroutines.createMethodNodeForCoroutineContext
 import org.jetbrains.kotlin.codegen.coroutines.createMethodNodeForIntercepted
@@ -19,6 +22,7 @@
 import org.jetbrains.kotlin.codegen.coroutines.isBuiltInSuspendCoroutineUninterceptedOrReturnInJvm
 import org.jetbrains.kotlin.codegen.intrinsics.bytecode
 import org.jetbrains.kotlin.codegen.intrinsics.classId
+import org.jetbrains.kotlin.codegen.inline.coroutines.FOR_INLINE_SUFFIX
 import org.jetbrains.kotlin.codegen.state.GenerationState
 import org.jetbrains.kotlin.codegen.state.KotlinTypeMapper
 import org.jetbrains.kotlin.config.isReleaseCoroutines
@@ -89,7 +93,7 @@
 
     protected val invocationParamBuilder = ParametersBuilder.newBuilder()
 
-    protected val expressionMap = linkedMapOf<Int, LambdaInfo>()
+    protected val expressionMap = linkedMapOf<Int, FunctionalArgument>()
 
     var activeLambda: LambdaInfo? = null
         protected set
@@ -240,7 +244,7 @@
                 extractDefaultLambdaOffsetAndDescriptor(jvmSignature, functionDescriptor)
             )
             for (lambda in defaultLambdas) {
-                invocationParamBuilder.buildParameters().getParameterByDeclarationSlot(lambda.offset).lambda = lambda
+                invocationParamBuilder.buildParameters().getParameterByDeclarationSlot(lambda.offset).functionalArgument = lambda
                 val prev = expressionMap.put(lambda.offset, lambda)
                 assert(prev == null) { "Lambda with offset ${lambda.offset} already exists: $prev" }
             }
@@ -316,7 +320,9 @@
 
     private fun generateClosuresBodies() {
         for (info in expressionMap.values) {
-            info.generateLambdaBody(sourceCompiler, reifiedTypeInliner)
+            if (info is LambdaInfo) {
+                info.generateLambdaBody(sourceCompiler, reifiedTypeInliner)
+            }
         }
     }
 
@@ -346,6 +352,12 @@
                 info.setRemapValue(remappedValue)
             } else {
                 info = invocationParamBuilder.addNextValueParameter(jvmType, false, remappedValue, parameterIndex)
+                info.functionalArgument = when (kind) {
+                    ValueKind.NON_INLINEABLE_ARGUMENT_FOR_INLINE_PARAMETER_CALLED_IN_SUSPEND ->
+                        NonInlineableArgumentForInlineableParameterCalledInSuspend(kotlinType?.isSuspendFunctionTypeOrSubtype == true)
+                    ValueKind.NON_INLINEABLE_ARGUMENT_FOR_INLINE_SUSPEND_PARAMETER -> NonInlineableArgumentForInlineableSuspendParameter
+                    else -> null
+                }
             }
 
             recordParameterValueInLocalVal(
@@ -401,8 +413,10 @@
     private fun putClosureParametersOnStack() {
         for (next in expressionMap.values) {
             //closure parameters for bounded callable references are generated inplace
-            if (next is ExpressionLambda && next.isBoundCallableReference) continue
-            putClosureParametersOnStack(next, null)
+            if (next is LambdaInfo) {
+                if (next is ExpressionLambda && next.isBoundCallableReference) continue
+                putClosureParametersOnStack(next, null)
+            }
         }
     }
 
@@ -534,7 +548,7 @@
         // 2) for inliner: with mangled name and without state machine
         private fun mangleSuspendInlineFunctionAsmMethodIfNeeded(functionDescriptor: FunctionDescriptor, asmMethod: Method): Method {
             if (!functionDescriptor.isSuspend) return asmMethod
-            return Method("${asmMethod.name}\$\$forInline", asmMethod.descriptor)
+            return Method("${asmMethod.name}$FOR_INLINE_SUFFIX", asmMethod.descriptor)
         }
 
         private fun getDirectMemberAndCallableFromObject(functionDescriptor: FunctionDescriptor): CallableMemberDescriptor {
@@ -545,7 +559,7 @@
         private fun cloneMethodNode(methodNode: MethodNode): MethodNode {
             methodNode.instructions.resetLabels()
             return MethodNode(
-                Opcodes.API_VERSION, methodNode.access, methodNode.name, methodNode.desc, methodNode.signature,
+                458752, methodNode.access, methodNode.name, methodNode.desc, methodNode.signature,
                 ArrayUtil.toStringArray(methodNode.exceptions)
             ).also(methodNode::accept)
         }
@@ -761,10 +775,21 @@
             }
         } else {
             val value = codegen.gen(argumentExpression)
-            putValueIfNeeded(parameterType, value, ValueKind.GENERAL, parameterIndex)
+            val kind = when {
+                isCallSiteIsSuspend(valueParameterDescriptor) -> ValueKind.NON_INLINEABLE_ARGUMENT_FOR_INLINE_PARAMETER_CALLED_IN_SUSPEND
+                isInlineSuspendParameter(valueParameterDescriptor) -> ValueKind.NON_INLINEABLE_ARGUMENT_FOR_INLINE_SUSPEND_PARAMETER
+                else -> ValueKind.GENERAL
+            }
+            putValueIfNeeded(parameterType, value, kind, parameterIndex)
         }
     }
 
+    private fun isInlineSuspendParameter(descriptor: ValueParameterDescriptor): Boolean =
+        functionDescriptor.isInline && !descriptor.isNoinline && descriptor.type.isSuspendFunctionTypeOrSubtype
+
+    private fun isCallSiteIsSuspend(descriptor: ValueParameterDescriptor): Boolean =
+        state.bindingContext[CodegenBinding.CALL_SITE_IS_SUSPEND_FOR_CROSSINLINE_LAMBDA, descriptor] == true
+
     private fun rememberClosure(expression: KtExpression, type: Type, parameter: ValueParameterDescriptor): LambdaInfo {
         val ktLambda = KtPsiUtil.deparenthesize(expression)
         assert(isInlinableParameterExpression(ktLambda)) { "Couldn't find inline expression in ${expression.text}" }
@@ -774,7 +799,7 @@
             parameter.isCrossinline, getBoundCallableReferenceReceiver(expression) != null
         ).also { lambda ->
             val closureInfo = invocationParamBuilder.addNextValueParameter(type, true, null, parameter.index)
-            closureInfo.lambda = lambda
+            closureInfo.functionalArgument = lambda
             expressionMap.put(closureInfo.index, lambda)
         }
     }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InlineMethodInstructionAdapter.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InlineMethodInstructionAdapter.java
@@ -12,7 +12,7 @@
 public class InlineMethodInstructionAdapter extends InstructionAdapter {
 
     InlineMethodInstructionAdapter(MethodVisitor methodVisitor) {
-        super(Opcodes.API_VERSION, methodVisitor);
+        super(458752, methodVisitor);
     }
 
     public void visitAnnotableParameterCount(int parameterCount, boolean visible) {
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InliningContext.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InliningContext.kt
@@ -9,7 +9,7 @@
 import org.jetbrains.kotlin.codegen.state.GenerationState
 
 class RootInliningContext(
-    expressionMap: Map<Int, LambdaInfo>,
+    expressionMap: Map<Int, FunctionalArgument>,
     state: GenerationState,
     nameGenerator: NameGenerator,
     val sourceCompilerForInline: SourceCompilerForInline,
@@ -22,7 +22,7 @@
 
 class RegeneratedClassContext(
     parent: InliningContext,
-    expressionMap: Map<Int, LambdaInfo>,
+    expressionMap: Map<Int, FunctionalArgument>,
     state: GenerationState,
     nameGenerator: NameGenerator,
     typeRemapper: TypeRemapper,
@@ -36,7 +36,7 @@
 
 open class InliningContext(
     val parent: InliningContext?,
-    val expressionMap: Map<Int, LambdaInfo>,
+    val expressionMap: Map<Int, FunctionalArgument>,
     val state: GenerationState,
     val nameGenerator: NameGenerator,
     val typeRemapper: TypeRemapper,
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InternalFinallyBlockInliner.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InternalFinallyBlockInliner.java
@@ -107,7 +107,7 @@
 
     private int initAndGetVarIndexForNonLocalReturnValue() {
         MaxLocalsCalculator tempCalcNode = new MaxLocalsCalculator(
-                Opcodes.API_VERSION,
+                458752,
                 inlineFun.access, inlineFun.desc, null
         );
         inlineFun.accept(tempCalcNode);
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InvokeCall.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/InvokeCall.java
@@ -19,11 +19,11 @@
 import org.jetbrains.annotations.Nullable;
 
 class InvokeCall {
-    public final LambdaInfo lambdaInfo;
+    public final FunctionalArgument functionalArgument;
     public final int finallyDepthShift;
 
-    InvokeCall(@Nullable LambdaInfo lambdaInfo, int finallyDepthShift) {
-        this.lambdaInfo = lambdaInfo;
+    InvokeCall(@Nullable FunctionalArgument functionalArgument, int finallyDepthShift) {
+        this.functionalArgument = functionalArgument;
         this.finallyDepthShift = finallyDepthShift;
     }
 }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/LambdaInfo.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/LambdaInfo.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
+ * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
  * that can be found in the license/LICENSE.txt file.
  */
 
@@ -33,7 +33,9 @@
 import org.jetbrains.org.objectweb.asm.tree.MethodNode
 import kotlin.properties.Delegates
 
-abstract class LambdaInfo(@JvmField val isCrossInline: Boolean) : LabelOwner {
+interface FunctionalArgument
+
+abstract class LambdaInfo(@JvmField val isCrossInline: Boolean) : FunctionalArgument, LabelOwner {
 
     abstract val isBoundCallableReference: Boolean
 
@@ -75,6 +77,8 @@
     }
 }
 
+class NonInlineableArgumentForInlineableParameterCalledInSuspend(val isSuspend: Boolean) : FunctionalArgument
+object NonInlineableArgumentForInlineableSuspendParameter : FunctionalArgument
 
 class DefaultLambda(
     override val lambdaClassType: Type,
@@ -106,7 +110,7 @@
         val classReader = buildClassReaderByInternalName(sourceCompiler.state, lambdaClassType.internalName)
         var isPropertyReference = false
         var isFunctionReference = false
-        classReader.accept(object : ClassVisitor(Opcodes.API_VERSION) {
+        classReader.accept(object : ClassVisitor(458752) {
             override fun visit(
                 version: Int,
                 access: Int,
@@ -188,7 +192,7 @@
         val jvmMethodSignature = typeMapper.mapSignatureSkipGeneric(invokeMethodDescriptor)
         val asmMethod = jvmMethodSignature.asmMethod
         val methodNode = MethodNode(
-            Opcodes.API_VERSION, AsmUtil.getMethodAsmFlags(invokeMethodDescriptor, OwnerKind.IMPLEMENTATION, sourceCompiler.state),
+            458752, AsmUtil.getMethodAsmFlags(invokeMethodDescriptor, OwnerKind.IMPLEMENTATION, sourceCompiler.state),
             asmMethod.name, asmMethod.descriptor, null, null
         )
 
@@ -224,7 +228,8 @@
 
     private val labels: Set<String>
 
-    private var closure: CalculatedClosure
+    var closure: CalculatedClosure
+        private set
 
     init {
         val bindingContext = typeMapper.bindingContext
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/MethodBodyVisitor.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/MethodBodyVisitor.kt
@@ -19,13 +19,13 @@
 import org.jetbrains.org.objectweb.asm.*
 import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter
 
-open class SkipMaxAndEndVisitor(mv: MethodVisitor) : InstructionAdapter(Opcodes.API_VERSION, mv) {
+open class SkipMaxAndEndVisitor(mv: MethodVisitor) : InstructionAdapter(458752, mv) {
     override fun visitMaxs(maxStack: Int, maxLocals: Int) {}
 
     override fun visitEnd() {}
 }
 
-open class MethodBodyVisitor(mv: MethodVisitor) : MethodVisitor(Opcodes.API_VERSION, mv) {
+open class MethodBodyVisitor(mv: MethodVisitor) : MethodVisitor(458752, mv) {
 
     @Suppress("NOTHING_TO_OVERRIDE")
     override fun visitAnnotableParameterCount(parameterCount: Int, visible: Boolean) {
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/MethodInliner.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/MethodInliner.kt
@@ -9,16 +9,14 @@
 import org.jetbrains.kotlin.codegen.coroutines.continuationAsmType
 import org.jetbrains.kotlin.codegen.coroutines.getOrCreateJvmSuspendFunctionView
 import org.jetbrains.kotlin.codegen.inline.FieldRemapper.Companion.foldName
-import org.jetbrains.kotlin.codegen.inline.coroutines.CoroutineTransformer
+import org.jetbrains.kotlin.codegen.inline.coroutines.*
 import org.jetbrains.kotlin.codegen.intrinsics.IntrinsicMethods
 import org.jetbrains.kotlin.codegen.optimization.ApiVersionCallsPreprocessingMethodTransformer
 import org.jetbrains.kotlin.codegen.optimization.FixStackWithLabelNormalizationMethodTransformer
-import org.jetbrains.kotlin.codegen.optimization.common.ControlFlowGraph
-import org.jetbrains.kotlin.codegen.optimization.common.InsnSequence
-import org.jetbrains.kotlin.codegen.optimization.common.asSequence
-import org.jetbrains.kotlin.codegen.optimization.common.isMeaningful
+import org.jetbrains.kotlin.codegen.optimization.common.*
 import org.jetbrains.kotlin.codegen.optimization.fixStack.peek
 import org.jetbrains.kotlin.codegen.optimization.fixStack.top
+import org.jetbrains.kotlin.codegen.optimization.transformer.MethodTransformer
 import org.jetbrains.kotlin.descriptors.FunctionDescriptor
 import org.jetbrains.kotlin.descriptors.ParameterDescriptor
 import org.jetbrains.kotlin.descriptors.ValueParameterDescriptor
@@ -104,7 +102,7 @@
         transformedNode.instructions.resetLabels()
 
         val resultNode = MethodNode(
-            Opcodes.API_VERSION, transformedNode.access, transformedNode.name, transformedNode.desc,
+            458752, transformedNode.access, transformedNode.name, transformedNode.desc,
             transformedNode.signature, transformedNode.exceptions?.toTypedArray()
         )
 
@@ -217,9 +215,12 @@
                 if (/*INLINE_RUNTIME.equals(owner) &&*/ isInvokeOnLambda(owner, name)) { //TODO add method
                     assert(!currentInvokes.isEmpty())
                     val invokeCall = currentInvokes.remove()
-                    val info = invokeCall.lambdaInfo
+                    val info = invokeCall.functionalArgument
 
-                    if (info == null) {
+                    if (info !is LambdaInfo) {
+                        if (info == NonInlineableArgumentForInlineableSuspendParameter) {
+                            super.visitMethodInsn(Opcodes.INVOKESTATIC, NOINLINE_CALL_MARKER, NOINLINE_CALL_MARKER, "()V", false)
+                        }
                         //noninlinable lambda
                         super.visitMethodInsn(opcode, owner, name, desc, itf)
                         return
@@ -263,7 +264,7 @@
                         listOf(*info.invokeMethod.argumentTypes), valueParameters, invokeParameters, valueParamShift, this, coroutineDesc
                     )
 
-                    if (invokeCall.lambdaInfo.invokeMethodDescriptor.valueParameters.isEmpty()) {
+                    if (info.invokeMethodDescriptor.valueParameters.isEmpty()) {
                         // There won't be no parameters processing and line call can be left without actual instructions.
                         // Note: if function is called on the line with other instructions like 1 + foo(), 'nop' will still be generated.
                         visitInsn(Opcodes.NOP)
@@ -366,6 +367,8 @@
                     ReifiedTypeInliner.isNeedClassReificationMarker(MethodInsnNode(opcode, owner, name, desc, false))
                 ) {
                     //we shouldn't process here content of inlining lambda it should be reified at external level except default lambdas
+                } else if (owner == NOINLINE_CALL_MARKER && name == NOINLINE_CALL_MARKER) {
+                    // do not generate multiple markers on single invoke
                 } else {
                     super.visitMethodInsn(opcode, owner, name, desc, itf)
                 }
@@ -386,7 +389,21 @@
 
         node.accept(lambdaInliner)
 
-        return resultNode
+        return surroundInvokesWithSuspendMarkersIfNeeded(resultNode)
+    }
+
+    private fun surroundInvokesWithSuspendMarkersIfNeeded(node: MethodNode): MethodNode {
+        val markers = node.instructions.asSequence().filter { it.isNoinlineCallMarker() }.toList()
+        if (markers.isEmpty()) return node
+        val invokes = markers.map { it.next as MethodInsnNode }
+        node.instructions.removeAll(markers)
+
+        val sourceFrames = MethodTransformer.analyze(inlineCallSiteInfo.ownerClassName, node, SourceInterpreter())
+        val toSurround = invokes.mapNotNull { insn ->
+            findReceiverOfInvoke(sourceFrames[node.instructions.indexOf(insn)], insn)?.let { insn to it }
+        }
+        surroundInvokesWithSuspendMarkers(node, toSurround)
+        return node
     }
 
     private fun isDefaultLambdaWithReification(lambdaInfo: LambdaInfo) =
@@ -398,7 +415,7 @@
         val capturedParamsSize = parameters.capturedParametersSizeOnStack
         val realParametersSize = parameters.realParametersSizeOnStack
         val transformedNode = MethodNode(
-            Opcodes.API_VERSION, node.access, node.name,
+            458752, node.access, node.name,
             Type.getMethodDescriptor(Type.getReturnType(node.desc), *(Type.getArgumentTypes(node.desc) + parameters.capturedTypes)),
             node.signature, node.exceptions?.toTypedArray()
         )
@@ -447,7 +464,7 @@
             override fun visitMethodInsn(opcode: Int, owner: String, name: String, desc: String, itf: Boolean) {
                 if (DEFAULT_LAMBDA_FAKE_CALL == owner) {
                     val index = name.substringAfter(DEFAULT_LAMBDA_FAKE_CALL).toInt()
-                    val lambda = getLambdaIfExists(index) as DefaultLambda
+                    val lambda = getFunctionalArgumentIfExists(index) as DefaultLambda
                     lambda.parameterOffsetsInDefault.zip(lambda.capturedVars).asReversed().forEach { (_, captured) ->
                         val originalBoundReceiverType = lambda.originalBoundReceiverType
                         if (lambda.isBoundCallableReference && AsmUtil.isPrimitive(originalBoundReceiverType)) {
@@ -522,22 +539,23 @@
                         val firstParameterIndex = frame.stackSize - paramCount
                         if (isInvokeOnLambda(owner, name) /*&& methodInsnNode.owner.equals(INLINE_RUNTIME)*/) {
                             val sourceValue = frame.getStack(firstParameterIndex)
-                            val lambdaInfo = getLambdaIfExistsAndMarkInstructions(sourceValue, true, instructions, sources, toDelete)
-                            invokeCalls.add(InvokeCall(lambdaInfo, currentFinallyDeep))
+                            val functionalArgument =
+                                getFunctionalArgumentIfExistsAndMarkInstructions(sourceValue, true, instructions, sources, toDelete)
+                            invokeCalls.add(InvokeCall(functionalArgument, currentFinallyDeep))
                         } else if (isSamWrapperConstructorCall(owner, name)) {
                             recordTransformation(SamWrapperTransformationInfo(owner, inliningContext, isAlreadyRegenerated(owner)))
                         } else if (isAnonymousConstructorCall(owner, name)) {
-                            val lambdaMapping = HashMap<Int, LambdaInfo>()
+                            val functionalArgumentMapping = HashMap<Int, FunctionalArgument>()
 
                             var offset = 0
                             var capturesAnonymousObjectThatMustBeRegenerated = false
                             for (i in 0 until paramCount) {
                                 val sourceValue = frame.getStack(firstParameterIndex + i)
-                                val lambdaInfo = getLambdaIfExistsAndMarkInstructions(
+                                val functionalArgument = getFunctionalArgumentIfExistsAndMarkInstructions(
                                     sourceValue, false, instructions, sources, toDelete
                                 )
-                                if (lambdaInfo != null) {
-                                    lambdaMapping.put(offset, lambdaInfo)
+                                if (functionalArgument != null) {
+                                    functionalArgumentMapping.put(offset, functionalArgument)
                                 } else if (i < argTypes.size && isAnonymousClassThatMustBeRegenerated(argTypes[i])) {
                                     capturesAnonymousObjectThatMustBeRegenerated = true
                                 }
@@ -547,7 +565,7 @@
 
                             recordTransformation(
                                 buildConstructorInvocation(
-                                    owner, cur.desc, lambdaMapping, awaitClassReification, capturesAnonymousObjectThatMustBeRegenerated
+                                    owner, cur.desc, functionalArgumentMapping, awaitClassReification, capturesAnonymousObjectThatMustBeRegenerated
                                 )
                             )
                             awaitClassReification = false
@@ -595,14 +613,16 @@
                         }
                     }
 
-                    cur.opcode == Opcodes.POP -> getLambdaIfExistsAndMarkInstructions(
+                    cur.opcode == Opcodes.POP -> getFunctionalArgumentIfExistsAndMarkInstructions(
                         frame.top()!!,
                         true,
                         instructions,
                         sources,
                         toDelete
                     )?.let {
-                        toDelete.add(cur)
+                        if (it is LambdaInfo) {
+                            toDelete.add(cur)
+                        }
                     }
 
                     cur.opcode == Opcodes.PUTFIELD -> {
@@ -620,8 +640,8 @@
                         ) {
                             val stackTransformations = mutableSetOf<AbstractInsnNode>()
                             val lambdaInfo =
-                                getLambdaIfExistsAndMarkInstructions(frame.peek(1)!!, false, instructions, sources, stackTransformations)
-                            if (lambdaInfo != null && stackTransformations.all { it is VarInsnNode }) {
+                                getFunctionalArgumentIfExistsAndMarkInstructions(frame.peek(1)!!, false, instructions, sources, stackTransformations)
+                            if (lambdaInfo is LambdaInfo && stackTransformations.all { it is VarInsnNode }) {
                                 assert(lambdaInfo.lambdaClassType.internalName == nodeRemapper.originalLambdaInternalName) {
                                     "Wrong bytecode template for contract template: ${lambdaInfo.lambdaClassType.internalName} != ${nodeRemapper.originalLambdaInternalName}"
                                 }
@@ -812,7 +832,7 @@
     private fun buildConstructorInvocation(
         anonymousType: String,
         desc: String,
-        lambdaMapping: Map<Int, LambdaInfo>,
+        lambdaMapping: Map<Int, FunctionalArgument>,
         needReification: Boolean,
         capturesAnonymousObjectThatMustBeRegenerated: Boolean
     ): AnonymousObjectTransformationInfo {
@@ -845,20 +865,20 @@
         return inliningContext.typeRemapper.hasNoAdditionalMapping(owner)
     }
 
-    internal fun getLambdaIfExists(insnNode: AbstractInsnNode): LambdaInfo? {
+    internal fun getFunctionalArgumentIfExists(insnNode: AbstractInsnNode): FunctionalArgument? {
         return when {
             insnNode.opcode == Opcodes.ALOAD ->
-                getLambdaIfExists((insnNode as VarInsnNode).`var`)
+                getFunctionalArgumentIfExists((insnNode as VarInsnNode).`var`)
             insnNode is FieldInsnNode && insnNode.name.startsWith(CAPTURED_FIELD_FOLD_PREFIX) ->
-                findCapturedField(insnNode, nodeRemapper).lambda
+                findCapturedField(insnNode, nodeRemapper).functionalArgument
             else ->
                 null
         }
     }
 
-    private fun getLambdaIfExists(varIndex: Int): LambdaInfo? {
+    private fun getFunctionalArgumentIfExists(varIndex: Int): FunctionalArgument? {
         if (varIndex < parameters.argsSizeOnStack) {
-            return parameters.getParameterByDeclarationSlot(varIndex).lambda
+            return parameters.getParameterByDeclarationSlot(varIndex).functionalArgument
         }
         return null
     }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/MethodInlinerUtil.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/MethodInlinerUtil.kt
@@ -1,17 +1,6 @@
 /*
- * Copyright 2010-2016 JetBrains s.r.o.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
+ * that can be found in the license/LICENSE.txt file.
  */
 
 package org.jetbrains.kotlin.codegen.inline
@@ -26,37 +15,39 @@
 import org.jetbrains.org.objectweb.asm.tree.analysis.Frame
 import org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue
 
-fun MethodInliner.getLambdaIfExistsAndMarkInstructions(
+fun MethodInliner.getFunctionalArgumentIfExistsAndMarkInstructions(
     sourceValue: SourceValue,
     processSwap: Boolean,
     insnList: InsnList,
     frames: Array<Frame<SourceValue>?>,
     toDelete: MutableSet<AbstractInsnNode>
-): LambdaInfo? {
+): FunctionalArgument? {
     val toDeleteInner = SmartSet.create<AbstractInsnNode>()
 
-    val lambdaSet = SmartSet.create<LambdaInfo?>()
-    sourceValue.insns.mapTo(lambdaSet) {
-        getLambdaIfExistsAndMarkInstructions(it, processSwap, insnList, frames, toDeleteInner)
+    val functionalArgumentSet = SmartSet.create<FunctionalArgument?>()
+    sourceValue.insns.mapTo(functionalArgumentSet) {
+        getFunctionalArgumentIfExistsAndMarkInstructions(it, processSwap, insnList, frames, toDeleteInner)
     }
 
-    return lambdaSet.singleOrNull()?.also {
-        toDelete.addAll(toDeleteInner)
+    return functionalArgumentSet.singleOrNull()?.also {
+        if (it is LambdaInfo) {
+            toDelete.addAll(toDeleteInner)
+        }
     }
 }
 
 private fun SourceValue.singleOrNullInsn() = insns.singleOrNull()
 
-private fun MethodInliner.getLambdaIfExistsAndMarkInstructions(
+private fun MethodInliner.getFunctionalArgumentIfExistsAndMarkInstructions(
     insnNode: AbstractInsnNode?,
     processSwap: Boolean,
     insnList: InsnList,
     frames: Array<Frame<SourceValue>?>,
     toDelete: MutableSet<AbstractInsnNode>
-): LambdaInfo? {
+): FunctionalArgument? {
     if (insnNode == null) return null
 
-    getLambdaIfExists(insnNode)?.let {
+    getFunctionalArgumentIfExists(insnNode)?.let {
         //delete lambda aload instruction
         toDelete.add(insnNode)
         return it
@@ -69,7 +60,7 @@
         if (storeIns is VarInsnNode && storeIns.getOpcode() == Opcodes.ASTORE) {
             val frame = frames[insnList.indexOf(storeIns)] ?: return null
             val topOfStack = frame.top()!!
-            getLambdaIfExistsAndMarkInstructions(topOfStack, processSwap, insnList, frames, toDelete)?.let {
+            getFunctionalArgumentIfExistsAndMarkInstructions(topOfStack, processSwap, insnList, frames, toDelete)?.let {
                 //remove intermediate lambda astore, aload instruction: see 'complexStack/simple.1.kt' test
                 toDelete.add(storeIns)
                 toDelete.add(insnNode)
@@ -79,7 +70,7 @@
     } else if (processSwap && insnNode.opcode == Opcodes.SWAP) {
         val swapFrame = frames[insnList.indexOf(insnNode)] ?: return null
         val dispatchReceiver = swapFrame.top()!!
-        getLambdaIfExistsAndMarkInstructions(dispatchReceiver, false, insnList, frames, toDelete)?.let {
+        getFunctionalArgumentIfExistsAndMarkInstructions(dispatchReceiver, false, insnList, frames, toDelete)?.let {
             //remove swap instruction (dispatch receiver would be deleted on recursion call): see 'complexStack/simpleExtension.1.kt' test
             toDelete.add(insnNode)
             return it
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/ObjectTransformer.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/ObjectTransformer.kt
@@ -64,7 +64,7 @@
         /*MAPPING File could contains mappings for several enum classes, we should filter one*/
         val methodNodes = arrayListOf<MethodNode>()
         val fieldNode = transformationInfo.fieldNode
-        classReader.accept(object : ClassVisitor(Opcodes.API_VERSION, classBuilder.visitor) {
+        classReader.accept(object : ClassVisitor(458752, classBuilder.visitor) {
             override fun visit(version: Int, access: Int, name: String, signature: String?, superName: String, interfaces: Array<String>) {
                 classBuilder.defineClass(null, version, access, name, signature, superName, interfaces)
             }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/ParameterInfo.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/ParameterInfo.java
@@ -29,7 +29,7 @@
     public final boolean isSkipped;
 
     private boolean isCaptured;
-    private LambdaInfo lambda;
+    private FunctionalArgument functionalArgument;
     //in case when parameter could be extracted from outer context (e.g. from local var)
     private StackValue remapValue;
 
@@ -68,13 +68,13 @@
     }
 
     @Nullable
-    public LambdaInfo getLambda() {
-        return lambda;
+    public FunctionalArgument getFunctionalArgument() {
+        return functionalArgument;
     }
 
     @NotNull
-    public ParameterInfo setLambda(@Nullable LambdaInfo lambda) {
-        this.lambda = lambda;
+    public ParameterInfo setFunctionalArgument(@Nullable FunctionalArgument functionalArgument) {
+        this.functionalArgument = functionalArgument;
         return this;
     }
 
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/ParametersBuilder.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/ParametersBuilder.kt
@@ -38,7 +38,7 @@
 
     fun addCapturedParam(original: CapturedParamInfo, newFieldName: String): CapturedParamInfo {
         val info = CapturedParamInfo(original.desc, newFieldName, original.isSkipped, nextParameterOffset, original.index)
-        info.lambda = original.lambda
+        info.functionalArgument = original.functionalArgument
         return addParameter(info)
     }
 
@@ -62,7 +62,7 @@
             CapturedParamDesc(containingLambdaType, fieldName, type), newFieldName, skipped, nextParameterOffset, original?.index ?: -1
         )
         if (original != null) {
-            info.lambda = original.lambda
+            info.functionalArgument = original.functionalArgument
         }
         return addParameter(info)
     }
@@ -116,7 +116,7 @@
             val builder = newBuilder()
             if (inlineLambda?.hasDispatchReceiver != false && !isStatic) {
                 //skipped this for inlined lambda cause it will be removed
-                builder.addThis(objectType, inlineLambda != null).lambda = inlineLambda
+                builder.addThis(objectType, inlineLambda != null).functionalArgument = inlineLambda
             }
 
             for (type in Type.getArgumentTypes(descriptor)) {
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/RegeneratedLambdaFieldRemapper.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/RegeneratedLambdaFieldRemapper.kt
@@ -75,7 +75,7 @@
 
 
         val result = StackValue.field(
-            if (field.isSkipped)
+            if (field.isSkipped && field.functionalArgument is LambdaInfo)
                 Type.getObjectType(parent!!.parent!!.newLambdaInternalName)
             else
                 field.getType(),
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/ReifiedTypeInliner.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/ReifiedTypeInliner.kt
@@ -170,7 +170,7 @@
     ) = rewriteNextTypeInsn(insn, Opcodes.CHECKCAST) { stubCheckcast: AbstractInsnNode ->
         if (stubCheckcast !is TypeInsnNode) return false
 
-        val newMethodNode = MethodNode(Opcodes.API_VERSION)
+        val newMethodNode = MethodNode(458752)
         generateAsCast(InstructionAdapter(newMethodNode), kotlinType, asmType, safe, isReleaseCoroutines)
 
         instructions.insert(insn, newMethodNode.instructions)
@@ -190,7 +190,7 @@
     ) = rewriteNextTypeInsn(insn, Opcodes.INSTANCEOF) { stubInstanceOf: AbstractInsnNode ->
         if (stubInstanceOf !is TypeInsnNode) return false
 
-        val newMethodNode = MethodNode(Opcodes.API_VERSION)
+        val newMethodNode = MethodNode(458752)
         generateIsCheck(InstructionAdapter(newMethodNode), kotlinType, asmType, isReleaseCoroutines)
 
         instructions.insert(insn, newMethodNode.instructions)
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/RemappingClassBuilder.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/RemappingClassBuilder.java
@@ -1,17 +1,6 @@
 /*
- * Copyright 2010-2016 JetBrains s.r.o.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
+ * that can be found in the license/LICENSE.txt file.
  */
 
 package org.jetbrains.kotlin.codegen.inline;
@@ -29,9 +18,13 @@
 import org.jetbrains.org.objectweb.asm.commons.*;
 import org.jetbrains.org.objectweb.asm.commons.FieldRemapper;
 
+import java.util.HashMap;
+import java.util.Map;
+
 public class RemappingClassBuilder extends DelegatingClassBuilder {
     private final ClassBuilder builder;
     private final Remapper remapper;
+    private final Map<String, FieldVisitor> spilledCoroutineVariables = new HashMap<>();
 
     public RemappingClassBuilder(@NotNull ClassBuilder builder, @NotNull Remapper remapper) {
         this.builder = builder;
@@ -68,9 +61,39 @@
             @Nullable String signature,
             @Nullable Object value
     ) {
-        return new FieldRemapper(
-                builder.newField(origin, access, name, remapper.mapDesc(desc), remapper.mapSignature(signature, true), value), remapper
+        if (spilledCoroutineVariables.containsKey(name)) return spilledCoroutineVariables.get(name);
+
+        FieldRemapper field = new FieldRemapper(
+                builder.newField(origin, access, name, this.remapper.mapDesc(desc), this.remapper.mapSignature(signature, true), value),
+                this.remapper
         );
+        if (isSpilledCoroutineVariableName(name)) {
+            spilledCoroutineVariables.put(name, field);
+        }
+        return field;
+    }
+
+    private static boolean isSpilledCoroutineVariableName(String name) {
+        if (name.length() < 3) return false;
+        switch (name.charAt(0)) {
+            case 'L':
+            case 'Z':
+            case 'C':
+            case 'B':
+            case 'S':
+            case 'I':
+            case 'F':
+            case 'J':
+            case 'D':
+                break;
+            default:
+                return false;
+        }
+        if (name.charAt(1) != '$') return false;
+        for (int i = 2; i < name.length(); ++i) {
+            if (!Character.isDigit(name.charAt(i))) return false;
+        }
+        return true;
     }
 
     @Override
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/SamWrapperTransformer.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/SamWrapperTransformer.kt
@@ -59,7 +59,7 @@
         val classReader = createClassReader()
         val classBuilder = createRemappingClassBuilderViaFactory(inliningContext)
 
-        classReader.accept(object : ClassVisitor(Opcodes.API_VERSION, classBuilder.visitor) {
+        classReader.accept(object : ClassVisitor(458752, classBuilder.visitor) {
             override fun visit(version: Int, access: Int, name: String, signature: String?, superName: String, interfaces: Array<String>) {
                 classBuilder.defineClass(null, version, access, name, signature, superName, interfaces)
             }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/SourceCompilerForInline.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/SourceCompilerForInline.kt
@@ -121,7 +121,7 @@
 
             val signature = codegen.state.typeMapper.mapSignatureSkipGeneric(context.functionDescriptor, context.contextKind)
             return InlineCallSiteInfo(
-                parentCodegen.className, signature.asmMethod.name, signature.asmMethod.descriptor
+                parentCodegen.className, signature.asmMethod.name, signature.asmMethod.descriptor, compilationContextFunctionDescriptor.isInlineOrInsideInline()
             )
         }
 
@@ -278,7 +278,7 @@
         val inliningFunction = element as KtDeclarationWithBody?
 
         val node = MethodNode(
-            Opcodes.API_VERSION,
+            458752,
             AsmUtil.getMethodAsmFlags(callableDescriptor, context.contextKind, state) or if (callDefault) Opcodes.ACC_STATIC else 0,
             asmMethod.name,
             asmMethod.descriptor, null, null
@@ -472,4 +472,8 @@
 
         }
     }
-}
\ No newline at end of file
+}
+
+private fun DeclarationDescriptor.isInlineOrInsideInline(): Boolean =
+    if (this is FunctionDescriptor && isInline) true
+    else containingDeclaration?.isInlineOrInsideInline() == true
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/TransformationInfo.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/TransformationInfo.kt
@@ -67,7 +67,7 @@
 class AnonymousObjectTransformationInfo internal constructor(
     override val oldClassName: String,
     private val needReification: Boolean,
-    val lambdasToInline: Map<Int, LambdaInfo>,
+    val functionalArguments: Map<Int, FunctionalArgument>,
     private val capturedOuterRegenerated: Boolean,
     private val alreadyRegenerated: Boolean,
     val constructorDesc: String?,
@@ -99,7 +99,7 @@
 
     override fun shouldRegenerate(sameModule: Boolean): Boolean =
         !alreadyRegenerated &&
-                (!lambdasToInline.isEmpty() || !sameModule || capturedOuterRegenerated || needReification || capturesAnonymousObjectThatMustBeRegenerated)
+                (!functionalArguments.isEmpty() || !sameModule || capturedOuterRegenerated || needReification || capturesAnonymousObjectThatMustBeRegenerated)
 
     override fun canRemoveAfterTransformation(): Boolean {
         // Note: It is unsafe to remove anonymous class that is referenced by GETSTATIC within lambda
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/coroutines/CoroutineTransformer.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/coroutines/CoroutineTransformer.kt
@@ -6,46 +6,51 @@
 package org.jetbrains.kotlin.codegen.inline.coroutines
 
 import com.intellij.util.ArrayUtil
+import org.jetbrains.kotlin.codegen.AsmUtil.CAPTURED_THIS_FIELD
 import org.jetbrains.kotlin.codegen.ClassBuilder
-import org.jetbrains.kotlin.codegen.coroutines.CoroutineTransformerMethodVisitor
-import org.jetbrains.kotlin.codegen.coroutines.getLastParameterIndex
-import org.jetbrains.kotlin.codegen.coroutines.isResumeImplMethodName
-import org.jetbrains.kotlin.codegen.coroutines.replaceFakeContinuationsWithRealOnes
+import org.jetbrains.kotlin.codegen.TransformationMethodVisitor
+import org.jetbrains.kotlin.codegen.coroutines.*
 import org.jetbrains.kotlin.codegen.inline.*
 import org.jetbrains.kotlin.codegen.optimization.common.asSequence
+import org.jetbrains.kotlin.codegen.optimization.common.findPreviousOrNull
+import org.jetbrains.kotlin.codegen.optimization.transformer.MethodTransformer
 import org.jetbrains.kotlin.config.isReleaseCoroutines
-import org.jetbrains.kotlin.descriptors.FunctionDescriptor
+import org.jetbrains.kotlin.descriptors.ClassDescriptor
+import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
 import org.jetbrains.kotlin.psi.KtElement
 import org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin
 import org.jetbrains.kotlin.utils.addToStdlib.cast
-import org.jetbrains.kotlin.utils.sure
+import org.jetbrains.org.objectweb.asm.MethodVisitor
 import org.jetbrains.org.objectweb.asm.Opcodes
-import org.jetbrains.org.objectweb.asm.tree.MethodInsnNode
-import org.jetbrains.org.objectweb.asm.tree.MethodNode
-import org.jetbrains.org.objectweb.asm.tree.TypeInsnNode
+import org.jetbrains.org.objectweb.asm.tree.*
+import org.jetbrains.org.objectweb.asm.tree.analysis.Frame
+import org.jetbrains.org.objectweb.asm.tree.analysis.SourceInterpreter
+import org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue
+
+const val NOINLINE_CALL_MARKER = "NOINLINE_CALL_MARKER"
+
+const val FOR_INLINE_SUFFIX = "\$\$forInline"
 
 class CoroutineTransformer(
     private val inliningContext: InliningContext,
     private val classBuilder: ClassBuilder,
     private val methods: List<MethodNode>,
-    private val superClassName: String
+    private val superClassName: String,
+    private val capturedParams: List<CapturedParamInfo>
 ) {
     private val state = inliningContext.state
+    // If we inline into inline function, we should generate both method with state-machine for Java interop and method without
+    // state-machine for further transformation/inlining.
+    private val generateForInline = inliningContext.callSiteInfo.isInlineOrInsideInline
 
-    fun shouldTransform(node: MethodNode): Boolean {
+    fun shouldSkip(node: MethodNode): Boolean = methods.any { it.name == node.name + FOR_INLINE_SUFFIX && it.desc == node.desc }
+
+    fun shouldGenerateStateMachine(node: MethodNode): Boolean {
+        // Continuations are similar to lambdas from bird's view, but we should never generate state machine for them
         if (isContinuationNotLambda()) return false
-        val crossinlineParam = crossinlineLambda() ?: return false
-        if (inliningContext.isInliningLambda && !inliningContext.isContinuation) return false
-        return when {
-            isSuspendFunction(node) -> true
-            isSuspendLambda(node) -> {
-                if (isStateMachine(node)) return false
-                val functionDescriptor =
-                    crossinlineParam.invokeMethodDescriptor.containingDeclaration as? FunctionDescriptor ?: return true
-                !functionDescriptor.isInline
-            }
-            else -> false
-        }
+        // there can be suspend lambdas inside inline functions, which do not
+        // capture crossinline lambdas, thus, there is no need to transform them
+        return isSuspendFunctionWithFakeConstructorCall(node) || (isSuspendLambda(node) && !isStateMachine(node))
     }
 
     private fun isContinuationNotLambda(): Boolean = inliningContext.isContinuation &&
@@ -57,14 +62,16 @@
     }?.cast()
 
     private fun isStateMachine(node: MethodNode): Boolean =
-        node.instructions.asSequence().any { it.opcode == Opcodes.INVOKESTATIC && (it as MethodInsnNode).name == "getCOROUTINE_SUSPENDED" }
+        node.instructions.asSequence().any { insn -> insn is LdcInsnNode && insn.cst == ILLEGAL_STATE_ERROR_MESSAGE }
 
     private fun isSuspendLambda(node: MethodNode) = isResumeImpl(node)
 
     fun newMethod(node: MethodNode): DeferredMethodVisitor {
-        val element = crossinlineLambda()?.functionWithBodyOrCallableReference.sure {
-            "crossinline lambda should have element"
-        }
+        // Find ANY element to report error about suspension point in monitor on.
+        val element = crossinlineLambda()?.functionWithBodyOrCallableReference
+            ?: inliningContext.root.sourceCompilerForInline.callElement as? KtElement
+            ?: error("crossinline lambda should have element")
+
         return when {
             isResumeImpl(node) -> {
                 assert(!isStateMachine(node)) {
@@ -72,74 +79,129 @@
                 }
                 newStateMachineForLambda(node, element)
             }
-            isSuspendFunction(node) -> newStateMachineForNamedFunction(node, element)
+            isSuspendFunctionWithFakeConstructorCall(node) -> newStateMachineForNamedFunction(node, element)
             else -> error("no need to generate state maching for ${node.name}")
         }
     }
 
     private fun isResumeImpl(node: MethodNode): Boolean =
-        state.languageVersionSettings.isResumeImplMethodName(node.name) &&
+        state.languageVersionSettings.isResumeImplMethodName(node.name.removeSuffix(FOR_INLINE_SUFFIX)) &&
                 inliningContext.isContinuation
 
-    private fun isSuspendFunction(node: MethodNode): Boolean = findFakeContinuationConstructorClassName(node) != null
+    private fun isSuspendFunctionWithFakeConstructorCall(node: MethodNode): Boolean = findFakeContinuationConstructorClassName(node) != null
 
     private fun newStateMachineForLambda(node: MethodNode, element: KtElement): DeferredMethodVisitor {
+        val name = node.name.removeSuffix(FOR_INLINE_SUFFIX)
         return DeferredMethodVisitor(
             MethodNode(
-                node.access, node.name, node.desc, node.signature,
+                node.access, name, node.desc, node.signature,
                 ArrayUtil.toStringArray(node.exceptions)
             )
         ) {
-            CoroutineTransformerMethodVisitor(
-                classBuilder.newMethod(
-                    JvmDeclarationOrigin.NO_ORIGIN,
-                    node.access,
-                    node.name,
-                    node.desc,
-                    node.signature,
-                    ArrayUtil.toStringArray(node.exceptions)
-                ), node.access, node.name, node.desc, null, null,
-                obtainClassBuilderForCoroutineState = { classBuilder },
-                element = element,
-                diagnostics = state.diagnostics,
-                languageVersionSettings = state.languageVersionSettings,
-                shouldPreserveClassInitialization = state.constructorCallNormalizationMode.shouldPreserveClassInitialization,
-                containingClassInternalName = classBuilder.thisName,
-                isForNamedFunction = false,
-                sourceFile = element.containingKtFile.name,
-                isCrossinlineLambda = inliningContext.isContinuation
+            val stateMachineBuilder = surroundNoinlineCallsWithMarkers(
+                node,
+                CoroutineTransformerMethodVisitor(
+                    createNewMethodFrom(node, name), node.access, name, node.desc, null, null,
+                    obtainClassBuilderForCoroutineState = { classBuilder },
+                    element = element,
+                    diagnostics = state.diagnostics,
+                    languageVersionSettings = state.languageVersionSettings,
+                    shouldPreserveClassInitialization = state.constructorCallNormalizationMode.shouldPreserveClassInitialization,
+                    containingClassInternalName = classBuilder.thisName,
+                    isForNamedFunction = false,
+                    sourceFile = element.containingKtFile.name
+                )
             )
+
+            if (generateForInline)
+                MethodNodeCopyingMethodVisitor(
+                    delegate = stateMachineBuilder,
+                    access = node.access,
+                    name = name,
+                    desc = node.desc,
+                    newMethod = { origin, newAccess, newName, newDesc ->
+                        classBuilder.newMethod(origin, newAccess, newName, newDesc, null, null)
+                    }
+                )
+            else
+                stateMachineBuilder
         }
     }
 
     private fun newStateMachineForNamedFunction(node: MethodNode, element: KtElement): DeferredMethodVisitor {
+        val name = node.name.removeSuffix(FOR_INLINE_SUFFIX)
         val continuationClassName = findFakeContinuationConstructorClassName(node)
         assert(inliningContext is RegeneratedClassContext)
         return DeferredMethodVisitor(
             MethodNode(
-                node.access, node.name, node.desc, node.signature,
+                node.access, name, node.desc, node.signature,
                 ArrayUtil.toStringArray(node.exceptions)
             )
         ) {
-            CoroutineTransformerMethodVisitor(
-                classBuilder.newMethod(
-                    JvmDeclarationOrigin.NO_ORIGIN, node.access, node.name, node.desc, node.signature,
-                    ArrayUtil.toStringArray(node.exceptions)
-                ), node.access, node.name, node.desc, null, null,
-                obtainClassBuilderForCoroutineState = { (inliningContext as RegeneratedClassContext).continuationBuilders[continuationClassName]!! },
-                element = element,
-                diagnostics = state.diagnostics,
-                languageVersionSettings = state.languageVersionSettings,
-                shouldPreserveClassInitialization = state.constructorCallNormalizationMode.shouldPreserveClassInitialization,
-                containingClassInternalName = classBuilder.thisName,
-                isForNamedFunction = true,
-                needDispatchReceiver = true,
-                internalNameForDispatchReceiver = classBuilder.thisName,
-                sourceFile = element.containingKtFile.name
+            val stateMachineBuilder = surroundNoinlineCallsWithMarkers(
+                node,
+                CoroutineTransformerMethodVisitor(
+                    createNewMethodFrom(node, name), node.access, name, node.desc, null, null,
+                    obtainClassBuilderForCoroutineState = { (inliningContext as RegeneratedClassContext).continuationBuilders[continuationClassName]!! },
+                    element = element,
+                    diagnostics = state.diagnostics,
+                    languageVersionSettings = state.languageVersionSettings,
+                    shouldPreserveClassInitialization = state.constructorCallNormalizationMode.shouldPreserveClassInitialization,
+                    containingClassInternalName = classBuilder.thisName,
+                    isForNamedFunction = true,
+                    needDispatchReceiver = true,
+                    internalNameForDispatchReceiver = classBuilder.thisName,
+                    sourceFile = element.containingKtFile.name
+                )
             )
+
+            if (generateForInline)
+                MethodNodeCopyingMethodVisitor(
+                    stateMachineBuilder, node.access, name, node.desc,
+                    newMethod = { origin, newAccess, newName, newDesc ->
+                        classBuilder.newMethod(origin, newAccess, newName, newDesc, null, null)
+                    }
+                )
+            else
+                stateMachineBuilder
         }
     }
 
+    private fun surroundNoinlineCallsWithMarkers(node: MethodNode, delegate: MethodVisitor): MethodVisitor =
+        SurroundSuspendLambdaCallsWithSuspendMarkersMethodVisitor(
+            delegate, node.access, node.name, node.desc, classBuilder.thisName, this::fieldIsCapturedSuspendLambda
+        )
+
+    private fun fieldIsCapturedSuspendLambda(field: FieldInsnNode): Boolean =
+        capturedParams.find { it.newFieldName == field.name }?.let { it.functionalArgument?.isSuspendLambda() == true }
+            ?: isSuspendLambdaCapturedByOuterObjectOrLambda(field)
+
+    // We cannot find the lambda in captured parameters: it came from object outside of the our reach:
+    // this can happen when the lambda capture by non-transformed closure:
+    //   inline fun inlineMe(crossinline c: suspend() -> Unit) = suspend { c() }
+    //   inline fun inlineMe2(crossinline c: suspend() -> Unit) = suspend { inlineMe { c() }() }
+    // Suppose, we inline inlineMe into inlineMe2: the only knowledge we have about inlineMe$1 is captured receiver (this$0)
+    // Thus, transformed lambda from inlineMe, inlineMe3$$inlined$inlineMe2$1 contains the following bytecode
+    //   ALOAD 0
+    //   GETFIELD inlineMe2$1$invokeSuspend$$inlined$inlineMe$1.this$0 : LScratchKt$inlineMe2$1;
+    //   GETFIELD inlineMe2$1.$c : Lkotlin/jvm/functions/Function1;
+    // Since inlineMe2's lambda is outside of reach of the inliner, find crossinline parameter from compilation context:
+    private fun isSuspendLambdaCapturedByOuterObjectOrLambda(field: FieldInsnNode): Boolean {
+        val functionDescriptor = inliningContext.root.sourceCompilerForInline.compilationContextFunctionDescriptor
+        val classDescriptor = functionDescriptor.findContainingClassOrLambda() ?: return false
+        return isCapturedSuspendLambda(classDescriptor, field.name, inliningContext.state.bindingContext)
+    }
+
+    private tailrec fun DeclarationDescriptor.findContainingClassOrLambda(): ClassDescriptor? =
+        if (containingDeclaration is ClassDescriptor) containingDeclaration as ClassDescriptor
+        else containingDeclaration?.findContainingClassOrLambda()
+
+    private fun createNewMethodFrom(node: MethodNode, name: String): MethodVisitor {
+        return classBuilder.newMethod(
+            JvmDeclarationOrigin.NO_ORIGIN, node.access, name, node.desc, node.signature, ArrayUtil.toStringArray(node.exceptions)
+        )
+    }
+
     fun replaceFakesWithReals(node: MethodNode) {
         findFakeContinuationConstructorClassName(node)?.let(::unregisterClassBuilder)?.let(ClassBuilder::done)
         replaceFakeContinuationsWithRealOnes(
@@ -163,4 +225,79 @@
             return (new as TypeInsnNode).desc
         }
     }
-}
\ No newline at end of file
+}
+
+class SurroundSuspendLambdaCallsWithSuspendMarkersMethodVisitor(
+    delegate: MethodVisitor, access: Int, name: String, desc: String,
+    private val thisName: String,
+    private val isCapturedSuspendLambda: (FieldInsnNode) -> Boolean
+) : TransformationMethodVisitor(delegate, access, name, desc, null, null) {
+    override fun performTransformations(methodNode: MethodNode) {
+        fun AbstractInsnNode.index() = methodNode.instructions.indexOf(this)
+
+        val sourceFrames = MethodTransformer.analyze(thisName, methodNode, SourceInterpreter())
+
+        val noinlineInvokes = arrayListOf<Pair<AbstractInsnNode, AbstractInsnNode>>()
+
+        for (insn in methodNode.instructions.asSequence()) {
+            if (insn.opcode != Opcodes.INVOKEINTERFACE) continue
+            insn as MethodInsnNode
+            if (!isInvokeOnLambda(insn.owner, insn.name)) continue
+            val frame = sourceFrames[insn.index()] ?: continue
+            val receiver = findReceiverOfInvoke(frame, insn).takeIf { it?.isSuspendLambda(insn) == true } as? FieldInsnNode ?: continue
+            val aload = receiver.findPreviousOrNull { it.opcode != Opcodes.GETFIELD } ?: error("GETFIELD cannot be the first instruction")
+            assert(aload.opcode == Opcodes.ALOAD) { "Before GETFIELD there shall be ALOAD" }
+            noinlineInvokes.add(insn to aload)
+        }
+
+        surroundInvokesWithSuspendMarkers(methodNode, noinlineInvokes)
+    }
+
+    private fun AbstractInsnNode.isSuspendLambda(invoke: MethodInsnNode): Boolean {
+        if (opcode != Opcodes.GETFIELD) return false
+        this as FieldInsnNode
+        if (desc != "L${invoke.owner};") return false
+        var current: FieldInsnNode? = this
+        // Unroll the battery of
+        // GETFIELD <outer1>.this$0 L<outer2>;
+        // GETFIELD <outer2>.this$0 L<outer3>;
+        // ...
+        // GETFIELD <outerN>.$action Lkotlin/jvm/functions/FunctionM;
+        while (current != null) {
+            if (current.owner == thisName) break
+            if (current.previous?.opcode != Opcodes.GETFIELD || current.previous.cast<FieldInsnNode>().name != CAPTURED_THIS_FIELD) return false
+            current = current.previous as FieldInsnNode
+        }
+        return isCapturedSuspendLambda(this)
+    }
+}
+
+private fun FunctionalArgument.isSuspendLambda(): Boolean =
+    (this is NonInlineableArgumentForInlineableParameterCalledInSuspend && isSuspend) ||
+            (this is PsiExpressionLambda && invokeMethodDescriptor.isSuspend)
+
+fun surroundInvokesWithSuspendMarkers(
+    methodNode: MethodNode,
+    noinlineInvokes: List<Pair<AbstractInsnNode, AbstractInsnNode>>
+) {
+    for ((invoke, aload) in noinlineInvokes) {
+        // Generate inline markers for stack transformation. It is required for local variables spilling.
+        methodNode.instructions.insertBefore(aload, withInstructionAdapter {
+            addInlineMarker(this, isStartNotEnd = true)
+        })
+        methodNode.instructions.insertBefore(invoke, withInstructionAdapter {
+            addSuspendMarker(this, isStartNotEnd = true)
+        })
+        methodNode.instructions.insert(invoke, withInstructionAdapter {
+            addSuspendMarker(this, isStartNotEnd = false)
+            addInlineMarker(this, isStartNotEnd = false)
+        })
+    }
+}
+
+// TODO: What to do if suddenly there are not exactly one receiver?
+fun findReceiverOfInvoke(frame: Frame<SourceValue>, insn: MethodInsnNode): AbstractInsnNode? =
+    frame.getStack(frame.stackSize - insn.owner.removePrefix(NUMBERED_FUNCTION_PREFIX).toInt() - 1)?.insns?.singleOrNull()
+
+fun AbstractInsnNode.isNoinlineCallMarker(): Boolean =
+    opcode == Opcodes.INVOKESTATIC && cast<MethodInsnNode>().let { it.owner == NOINLINE_CALL_MARKER && it.name == NOINLINE_CALL_MARKER }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/inlineCodegenUtils.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/inlineCodegenUtils.kt
@@ -95,7 +95,7 @@
     lines[0] = Integer.MAX_VALUE
     lines[1] = Integer.MIN_VALUE
 
-    cr.accept(object : ClassVisitor(Opcodes.API_VERSION) {
+    cr.accept(object : ClassVisitor(458752) {
 
         override fun visitSource(source: String?, debug: String?) {
             super.visitSource(source, debug)
@@ -123,7 +123,7 @@
                 throw AssertionError("Can't find proper '$name' method for inline: ambiguity between '${existing.name + existing.desc}' and '${name + desc}'")
             }
 
-            return object : MethodNode(Opcodes.API_VERSION, access, name, desc, signature, exceptions) {
+            return object : MethodNode(458752, access, name, desc, signature, exceptions) {
                 override fun visitLineNumber(line: Int, start: Label) {
                     super.visitLineNumber(line, start)
                     lines[0] = Math.min(lines[0], line)
@@ -248,7 +248,7 @@
             internalName.substringAfterLast('/').substringAfterLast("$", "").isInteger()
 
 fun wrapWithMaxLocalCalc(methodNode: MethodNode) =
-    MaxStackFrameSizeAndLocalsCalculator(Opcodes.API_VERSION, methodNode.access, methodNode.desc, methodNode)
+    MaxStackFrameSizeAndLocalsCalculator(458752, methodNode.access, methodNode.desc, methodNode)
 
 private fun String.isInteger(radix: Int = 10) = toIntOrNull(radix) != null
 
@@ -301,7 +301,7 @@
     }
 }
 
-internal fun createEmptyMethodNode() = MethodNode(Opcodes.API_VERSION, 0, "fake", "()V", null, null)
+internal fun createEmptyMethodNode() = MethodNode(458752, 0, "fake", "()V", null, null)
 
 internal fun createFakeContinuationMethodNodeForInline(): MethodNode {
     val methodNode = createEmptyMethodNode()
@@ -554,7 +554,7 @@
     val isValueOf = "enumValueOf" == name
     val invokeType = typeMapper.mapType(type)
     val desc = getSpecialEnumFunDescriptor(invokeType, isValueOf)
-    val node = MethodNode(Opcodes.API_VERSION, Opcodes.ACC_STATIC, "fake", desc, null, null)
+    val node = MethodNode(458752, Opcodes.ACC_STATIC, "fake", desc, null, null)
     ExpressionCodegen.putReifiedOperationMarkerIfTypeIsReifiedParameterWithoutPropagation(
         type,
         ReifiedTypeInliner.OperationKind.ENUM_REIFIED,
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/transformationUtils.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/inline/transformationUtils.kt
@@ -25,7 +25,7 @@
 fun getNewFieldsToGenerate(params: List<CapturedParamInfo>): List<NewJavaField> {
     return params.filter {
         //not inlined
-        it.lambda == null
+        it.functionalArgument !is LambdaInfo
     }.map {
         NewJavaField(it.newFieldName, it.type, it.isSkipInConstructor)
     }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/optimization/boxing/PopBackwardPropagationTransformer.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/optimization/boxing/PopBackwardPropagationTransformer.kt
@@ -119,7 +119,7 @@
             throw AssertionError("Incorrect bytecode at ${methodNode.instructions.indexOf(insn)}: ${insn.debugText} $frame")
         }
 
-        private inner class HazardsTrackingInterpreter : SourceInterpreter(Opcodes.API_VERSION) {
+        private inner class HazardsTrackingInterpreter : SourceInterpreter(458752) {
             override fun naryOperation(insn: AbstractInsnNode, values: MutableList<out SourceValue>): SourceValue {
                 for (value in values) {
                     value.insns.markAsDontTouch()
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/optimization/boxing/RedundantBoxingMethodTransformer.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/optimization/boxing/RedundantBoxingMethodTransformer.kt
@@ -251,7 +251,7 @@
         castWithType: Pair<AbstractInsnNode, Type>
     ) {
         val castInsn = castWithType.getFirst()
-        val castInsnsListener = MethodNode(Opcodes.API_VERSION)
+        val castInsnsListener = MethodNode(458752)
         InstructionAdapter(castInsnsListener).cast(value.unboxedType, castWithType.getSecond())
 
         for (insn in castInsnsListener.instructions.toArray()) {
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/optimization/common/OptimizationBasicInterpreter.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/optimization/common/OptimizationBasicInterpreter.java
@@ -34,7 +34,7 @@
 
 public class OptimizationBasicInterpreter extends Interpreter<BasicValue> implements Opcodes {
     public OptimizationBasicInterpreter() {
-        super(API_VERSION);
+        super(458752);
     }
 
     @Override
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/optimization/common/Util.kt
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/optimization/common/Util.kt
@@ -78,8 +78,8 @@
     maxStack = -1
     accept(
         MaxStackFrameSizeAndLocalsCalculator(
-            Opcodes.API_VERSION, access, desc,
-            object : MethodVisitor(Opcodes.API_VERSION) {
+            458752, access, desc,
+            object : MethodVisitor(458752) {
                 override fun visitMaxs(maxStack: Int, maxLocals: Int) {
                     this@prepareForEmitting.maxStack = maxStack
                 }
--- a/compiler/backend/src/org/jetbrains/kotlin/codegen/optimization/transformer/MethodTransformer.java
+++ b/compiler/backend/src/org/jetbrains/kotlin/codegen/optimization/transformer/MethodTransformer.java
@@ -35,11 +35,10 @@
         }
     }
 
-    @NotNull
     public static <V extends Value> Frame<V>[] analyze(
-            @NotNull String internalClassName,
-            @NotNull MethodNode node,
-            @NotNull Interpreter<V> interpreter
+            String internalClassName,
+            MethodNode node,
+            Interpreter<V> interpreter
     ) {
         return runAnalyzer(new Analyzer<>(interpreter), internalClassName, node);
     }
--- a/compiler/build.gradle
+++ b/compiler/build.gradle
@@ -8,10 +8,9 @@
     id("jps-compatible")
 }
 
-project.otherCompilerModules.removeAll([null])
 ext.compilerModules = rootProject.compilerModules
 ext.otherCompilerModules = compilerModules.collect { if(it != path){return it} }
-
+project.otherCompilerModules.removeAll([null])
 ext{
 	effectSystemEnabled = rootProject.effectSystemEnabled
 	newInferenceEnabled = rootProject.newInferenceEnabled
@@ -40,16 +39,16 @@
     testCompile(project(":kotlin-script-runtime"))
     testCompile(project(":kotlin-test:kotlin-test-jvm"))
 
-    testCompile(kotlinStdlib())
+    testCompile(DependenciesKt.customKotlinStdlib(project,null))
 
     testCompile(DependenciesKt.customCommonDep(project,"junit:junit"))
     testCompileOnly(project(":kotlin-test:kotlin-test-jvm"))
-    testCompileOnly(project(":kotlin-test:kotlin-test-junit"))
-    testCompile(DependenciesKt.customProjectTests(dependencies,":compiler:tests-common"))
-    testCompile(DependenciesKt.customProjectTests(dependencies,":compiler:fir:psi2fir"))
-    testCompile(DependenciesKt.customProjectTests(dependencies,":compiler:fir:resolve"))
-    testCompile(DependenciesKt.customProjectTests(dependencies,":generators:test-generator"))
-    testCompile(project(":compiler:ir.ir2cfg"))
+    //testCompileOnly(project(":kotlin-test:kotlin-test-junit"))
+    //testCompile(DependenciesKt.customProjectTests(dependencies,":compiler:tests-common"))
+    //testCompile(DependenciesKt.customProjectTests(dependencies,":compiler:fir:psi2fir"))
+    //testCompile(DependenciesKt.customProjectTests(dependencies,":compiler:fir:resolve"))
+    //testCompile(DependenciesKt.customProjectTests(dependencies,":generators:test-generator"))
+    //testCompile(project(":compiler:ir.ir2cfg"))
     testCompile(project(":compiler:ir.tree")) // used for deepCopyWithSymbols call that is removed by proguard from the compiler TODO: make it more straightforward
     testCompile(project(":kotlin-scripting-compiler"))
     testCompile(project(":kotlin-script-util"))
@@ -58,9 +57,9 @@
     otherCompilerModules.each {
         testCompileOnly(project(it))
     }
-
     testCompileOnly(IntellijDependenciesKt.customIntellijCoreDep(project)) { IntellijDependenciesKt.customIncludeJars(it,["intellij-core"],null) }
     testCompileOnly(IntellijDependenciesKt.getIntellijDep(project,"intellij")) { IntellijDependenciesKt.customIncludeJars(it,["openapi", "idea", "idea_rt", "util", "asm-all"], rootProject) }
+
     testRuntime(project(":kotlin-reflect"))
     testRuntime(project(":kotlin-daemon-client"))
     testRuntime(AndroidSdkDependenciesKt.customAndroidDxJar(project))
@@ -87,8 +86,10 @@
     include("META-INF/extensions/compiler.xml")
 }
 
-TasksKt.customProjectTest(project,rootDir,configurations.antLauncherJar.asPath,"test","compiler")
+TasksKt.customProjectTest(project,"test"){
+	it.workingDir = rootDir
+}
 
-task generateTests {return CommonUtilKt.customGenerator(project,"org.jetbrains.kotlin.generators.tests.GenerateCompilerTestsKt",null)}
+//task generateTests {return CommonUtilKt.customGenerator(project,"org.jetbrains.kotlin.generators.tests.GenerateCompilerTestsKt",null)}
 
-ArtifactsKt.customTestsJar(project,"compiler")
+ArtifactsKt.customTestsJar(project){}
--- a/compiler/compiler.pro
+++ b/compiler/compiler.pro
@@ -25,11 +25,24 @@
 -dontwarn com.intellij.util.CompressionUtil
 -dontwarn com.intellij.util.SnappyInitializer
 -dontwarn com.intellij.util.SVGLoader
+-dontwarn org.apache.oro.text.GenericPatternCache
+-dontwarn org.apache.oro.text.awk.AwkCompiler
+-dontwarn org.apache.oro.text.perl.Perl5Util
+-dontwarn org.apache.oro.text.regex.Perl5Compiler
+-dontwarn org.apache.oro.text.regex.Perl5Debug
 -dontwarn com.intellij.util.SVGLoader$MyTranscoder
+-dontwarn one.util.streamex.CrossSpliterator
+-dontwarn net.jpountz.lz4.LZ4Compressor
+-dontwarn net.jpountz.lz4.LZ4FastDecompressor
+-dontwarn net.jpountz.lz4.LZ4SafeDecompressor
+-dontwarn net.jpountz.xxhash.XXHash32
+-dontwarn net.jpountz.xxhash.XXHash64
 -dontwarn net.sf.cglib.**
 -dontwarn org.objectweb.asm.** # this is ASM3, the old version that we do not use
 -dontwarn com.sun.jna.NativeString
 -dontwarn com.sun.jna.WString
+-dontwarn com.sun.jna.ELFAnalyser*
+-dontwarn com.sun.jna.platform.mac.XAttrUtil
 -dontwarn com.intellij.psi.util.PsiClassUtil
 -dontwarn org.apache.hadoop.io.compress.*
 -dontwarn com.google.j2objc.annotations.Weak
--- a/compiler/daemon/daemon-common/src/org/jetbrains/kotlin/daemon/common/CompilationOptions.kt
+++ b/compiler/daemon/daemon-common/src/org/jetbrains/kotlin/daemon/common/CompilationOptions.kt
@@ -64,8 +64,7 @@
          */
         val outputFiles: List<File>,
     val multiModuleICSettings: MultiModuleICSettings,
-    val modulesInfo: IncrementalModuleInfo,
-    val classpathFqNamesHistory: File? = null
+    val modulesInfo: IncrementalModuleInfo
 ) : CompilationOptions(compilerMode, targetPlatform, reportCategories, reportSeverity, requestedCompilationResults) {
     companion object {
         const val serialVersionUID: Long = 0
@@ -81,7 +80,6 @@
                "multiModuleICSettings=$multiModuleICSettings, " +
                "usePreciseJavaTracking=$usePreciseJavaTracking" +
                "outputFiles=$outputFiles" +
-               "classpathFqNamesHistory=$classpathFqNamesHistory" +
                ")"
     }
 }
--- a/compiler/daemon/src/org/jetbrains/kotlin/daemon/CompileServiceImpl.kt
+++ b/compiler/daemon/src/org/jetbrains/kotlin/daemon/CompileServiceImpl.kt
@@ -583,19 +583,15 @@
             }
         }
 
-        val outputFiles = incrementalCompilationOptions.outputFiles.toMutableList()
-        incrementalCompilationOptions.classpathFqNamesHistory?.let { outputFiles.add(it) }
-
         val compiler = IncrementalJvmCompilerRunner(
             workingDir,
             javaSourceRoots,
             reporter,
             buildHistoryFile = incrementalCompilationOptions.multiModuleICSettings.buildHistoryFile,
-            outputFiles = outputFiles,
+            outputFiles = incrementalCompilationOptions.outputFiles,
             usePreciseJavaTracking = incrementalCompilationOptions.usePreciseJavaTracking,
             modulesApiHistory = modulesApiHistory,
-            kotlinSourceFilesExtensions = allKotlinExtensions,
-            classpathFqNamesHistory = incrementalCompilationOptions.classpathFqNamesHistory
+            kotlinSourceFilesExtensions = allKotlinExtensions
         )
         return try {
             compiler.compile(allKotlinFiles, k2jvmArgs, compilerMessageCollector, changedFiles)
--- a/compiler/frontend/build.gradle.kts
+++ /dev/null
@@ -1,25 +0,0 @@
-
-plugins {
-    kotlin("jvm")
-    id("jps-compatible")
-}
-
-dependencies {
-    compile(project(":kotlin-annotations-jvm"))
-    compile(project(":core:descriptors"))
-    compile(project(":core:deserialization"))
-    compile(project(":compiler:util"))
-    compile(project(":compiler:container"))
-    compile(project(":compiler:resolution"))
-    compile(project(":compiler:psi"))
-    compile(project(":compiler:frontend.common"))
-    compile(project(":kotlin-script-runtime"))
-    compile(commonDep("io.javaslang","javaslang"))
-    compileOnly(intellijCoreDep()) { includeJars("intellij-core") }
-    compileOnly(intellijDep()) { includeJars("trove4j", "guava", rootProject = rootProject) }
-}
-
-sourceSets {
-    "main" { projectDefault() }
-    "test" {}
-}
--- a/compiler/frontend/src/org/jetbrains/kotlin/resolve/calls/smartcasts/DataFlowInfoImpl.kt
+++ b/compiler/frontend/src/org/jetbrains/kotlin/resolve/calls/smartcasts/DataFlowInfoImpl.kt
@@ -18,7 +18,7 @@
 
 import com.google.common.collect.LinkedHashMultimap
 import com.google.common.collect.SetMultimap
-import javaslang.Tuple2
+import io.vavr.Tuple2
 import org.jetbrains.kotlin.builtins.KotlinBuiltIns
 import org.jetbrains.kotlin.config.LanguageFeature
 import org.jetbrains.kotlin.config.LanguageVersionSettings
--- a/compiler/frontend/src/org/jetbrains/kotlin/util/javaslang/javaslangAdapters.kt
+++ b/compiler/frontend/src/org/jetbrains/kotlin/util/javaslang/javaslangAdapters.kt
@@ -16,14 +16,14 @@
 
 package org.jetbrains.kotlin.util.javaslang
 
-import javaslang.Tuple2
-import javaslang.control.Option
+import io.vavr.Tuple2
+import io.vavr.control.Option
 
-typealias ImmutableMap<K, V> = javaslang.collection.Map<K, V>
-typealias ImmutableHashMap<K, V> = javaslang.collection.HashMap<K, V>
-typealias ImmutableSet<E> = javaslang.collection.Set<E>
-typealias ImmutableHashSet<E> = javaslang.collection.HashSet<E>
-typealias ImmutableLinkedHashSet<E> = javaslang.collection.LinkedHashSet<E>
+typealias ImmutableMap<K, V> = io.vavr.collection.Map<K, V>
+typealias ImmutableHashMap<K, V> = io.vavr.collection.HashMap<K, V>
+typealias ImmutableSet<E> = io.vavr.collection.Set<E>
+typealias ImmutableHashSet<E> = io.vavr.collection.HashSet<E>
+typealias ImmutableLinkedHashSet<E> = io.vavr.collection.LinkedHashSet<E>
 
 operator fun <T> Tuple2<T, *>.component1(): T = _1()
 operator fun <T> Tuple2<*, T>.component2(): T = _2()
--- a/compiler/frontend.java/src/org/jetbrains/kotlin/load/java/structure/impl/classFiles/commonMixins.kt
+++ b/compiler/frontend.java/src/org/jetbrains/kotlin/load/java/structure/impl/classFiles/commonMixins.kt
@@ -23,7 +23,7 @@
 import org.jetbrains.kotlin.load.java.structure.MapBasedJavaAnnotationOwner
 import org.jetbrains.org.objectweb.asm.Opcodes
 
-internal const val ASM_API_VERSION_FOR_CLASS_READING = Opcodes.API_VERSION
+internal const val ASM_API_VERSION_FOR_CLASS_READING = 458752
 
 internal interface BinaryJavaModifierListOwner : JavaModifierListOwner, MapBasedJavaAnnotationOwner {
     val access: Int
--- a/compiler/frontend.java/src/org/jetbrains/kotlin/load/kotlin/FileBasedKotlinClass.java
+++ b/compiler/frontend.java/src/org/jetbrains/kotlin/load/kotlin/FileBasedKotlinClass.java
@@ -34,9 +34,10 @@
 import java.util.*;
 
 import static org.jetbrains.org.objectweb.asm.ClassReader.*;
-import static org.jetbrains.org.objectweb.asm.Opcodes.API_VERSION;
+
 
 public abstract class FileBasedKotlinClass implements KotlinJvmBinaryClass {
+	static int API_VERSION=458752;
     private final ClassId classId;
     private final int classVersion;
     private final KotlinClassHeader classHeader;
--- a/compiler/frontend.java/src/org/jetbrains/kotlin/resolve/jvm/modules/JavaModuleInfo.kt
+++ b/compiler/frontend.java/src/org/jetbrains/kotlin/resolve/jvm/modules/JavaModuleInfo.kt
@@ -65,11 +65,11 @@
             val exports = arrayListOf<Exports>()
 
             try {
-                ClassReader(contents).accept(object : ClassVisitor(Opcodes.API_VERSION) {
+                ClassReader(contents).accept(object : ClassVisitor(458752) {
                     override fun visitModule(name: String, access: Int, version: String?): ModuleVisitor {
                         moduleName = name
 
-                        return object : ModuleVisitor(Opcodes.API_VERSION) {
+                        return object : ModuleVisitor(458752) {
                             override fun visitRequire(module: String, access: Int, version: String?) {
                                 requires.add(Requires(module, (access and ACC_TRANSITIVE) != 0))
                             }
--- a/compiler/incremental-compilation-impl/src/org/jetbrains/kotlin/incremental/IncrementalCompilerRunner.kt
+++ b/compiler/incremental-compilation-impl/src/org/jetbrains/kotlin/incremental/IncrementalCompilerRunner.kt
@@ -313,7 +313,7 @@
 
     open fun runWithNoDirtyKotlinSources(caches: CacheManager): Boolean = false
 
-    protected open fun processChangesAfterBuild(
+    private fun processChangesAfterBuild(
         compilationMode: CompilationMode,
         currentBuildInfo: BuildInfo,
         dirtyData: DirtyData
--- a/compiler/incremental-compilation-impl/src/org/jetbrains/kotlin/incremental/IncrementalJvmCompilerRunner.kt
+++ b/compiler/incremental-compilation-impl/src/org/jetbrains/kotlin/incremental/IncrementalJvmCompilerRunner.kt
@@ -110,8 +110,7 @@
     buildHistoryFile: File,
     outputFiles: Collection<File>,
     private val modulesApiHistory: ModulesApiHistory,
-    override val kotlinSourceFilesExtensions: List<String> = DEFAULT_KOTLIN_SOURCE_FILES_EXTENSIONS,
-    private val classpathFqNamesHistory: File? = null
+    override val kotlinSourceFilesExtensions: List<String> = DEFAULT_KOTLIN_SOURCE_FILES_EXTENSIONS
 ) : IncrementalCompilerRunner<K2JVMCompilerArguments, IncrementalJvmCachesManager>(
     workingDir,
     "caches-jvm",
@@ -258,28 +257,6 @@
         }
     }
 
-    override fun processChangesAfterBuild(compilationMode: CompilationMode, currentBuildInfo: BuildInfo, dirtyData: DirtyData) {
-        super.processChangesAfterBuild(compilationMode, currentBuildInfo, dirtyData)
-
-        classpathFqNamesHistory ?: return
-        classpathFqNamesHistory.mkdirs()
-
-        val historyFiles = classpathFqNamesHistory.listFiles()
-        if (dirtyClasspathChanges.isEmpty() && historyFiles.isNotEmpty()) {
-            // Don't write an empty file. We check there is at least one file so that downstream task can mark what it has processed.
-            return
-        }
-
-        if (historyFiles.size > 10) {
-            historyFiles.minBy { it.lastModified() }!!.delete()
-        }
-        val newHistoryFile = classpathFqNamesHistory.resolve(System.currentTimeMillis().toString())
-        ObjectOutputStream(newHistoryFile.outputStream().buffered()).use {
-            val listOfNames = dirtyClasspathChanges.map { it.toString() }.toList()
-            it.writeObject(listOfNames)
-        }
-    }
-
     override fun postCompilationHook(exitCode: ExitCode) {}
 
     override fun updateCaches(
--- a/compiler/ir/backend.jvm/src/org/jetbrains/kotlin/backend/jvm/codegen/IrInlineCodegen.kt
+++ b/compiler/ir/backend.jvm/src/org/jetbrains/kotlin/backend/jvm/codegen/IrInlineCodegen.kt
@@ -99,7 +99,7 @@
             parameter.type.isExtensionFunctionType
         ).also { lambda ->
             val closureInfo = invocationParamBuilder.addNextValueParameter(type, true, null, parameter.index)
-            closureInfo.lambda = lambda
+            closureInfo.functionalArgument = lambda
             expressionMap[closureInfo.index] = lambda
         }
     }
--- a/compiler/ir/backend.jvm/src/org/jetbrains/kotlin/backend/jvm/codegen/IrSourceCompilerForInline.kt
+++ b/compiler/ir/backend.jvm/src/org/jetbrains/kotlin/backend/jvm/codegen/IrSourceCompilerForInline.kt
@@ -63,7 +63,7 @@
         get() = OwnerKind.getMemberOwnerKind(callElement.descriptor.containingDeclaration)
 
     override val inlineCallSiteInfo: InlineCallSiteInfo
-        get() = InlineCallSiteInfo("TODO", null, null)
+        get() = InlineCallSiteInfo("TODO", null, null, false)
 
     override val lazySourceMapper: DefaultSourceMapper
         get() = codegen.classCodegen.getOrCreateSourceMapper()
@@ -115,7 +115,7 @@
         val functionCodegen = object : FunctionCodegen(irFunction, fakeClassCodegen) {
             override fun createMethod(flags: Int, signature: JvmMethodGenericSignature): MethodVisitor {
                 node = MethodNode(
-                    Opcodes.API_VERSION,
+                    458752,
                     flags,
                     signature.asmMethod.name, signature.asmMethod.descriptor,
                     signature.genericsSignature, null
--- a/compiler/preloader/instrumentation/src/org/jetbrains/kotlin/preloading/instrumentation/InterceptionInstrumenter.java
+++ b/compiler/preloader/instrumentation/src/org/jetbrains/kotlin/preloading/instrumentation/InterceptionInstrumenter.java
@@ -265,7 +265,7 @@
     private byte[] instrument(byte[] classData, List<MethodInstrumenter> instrumenters) {
         ClassReader cr = new ClassReader(classData);
         ClassWriter cw = new ClassWriter(cr, 0);
-        cr.accept(new ClassVisitor(API_VERSION, cw) {
+        cr.accept(new ClassVisitor(458752, cw) {
             private final Map<MethodInstrumenter, String> matchedMethods = new HashMap<>();
 
             @Override
@@ -316,7 +316,7 @@
                 int maxStackDepth = getMaxStackDepth(name, desc, normalReturnData, enterData, exceptionData);
                 boolean isConstructor = "<init>".equals(name);
 
-                return new MethodVisitor(API_VERSION, mv) {
+                return new MethodVisitor(458752, mv) {
 
                     private InstructionAdapter ia = null;
 
@@ -421,7 +421,7 @@
             }
 
             private TraceMethodVisitor getDumpingVisitorWrapper(MethodVisitor mv, String methodName, String methodDesc) {
-                return new TraceMethodVisitor(mv, new Textifier(API_VERSION) {
+                return new TraceMethodVisitor(mv, new Textifier(458752) {
                     @Override
                     public void visitMethodEnd() {
                         System.out.println(cr.getClassName() + ":" + methodName + methodDesc);
--- /dev/null
+++ b/compiler/testData/codegen/box/coroutines/javaInterop/objectWithSeveralSuspends.kt
@@ -0,0 +1,192 @@
+// IGNORE_BACKEND: JVM_IR
+// TARGET_BACKEND: JVM
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// NO_CHECK_LAMBDA_INLINING
+// CHECK_STATE_MACHINE
+
+// FILE: inlineMe.kt
+
+package test
+
+import helpers.*
+
+interface SuspendRunnable {
+    suspend fun run()
+    suspend fun run1()
+    suspend fun run2()
+}
+
+inline fun inlineMe(crossinline c: suspend () -> Unit) = object : SuspendRunnable {
+    override suspend fun run() {
+        c(); c()
+    }
+    override suspend fun run1() {
+        c(); c()
+    }
+    override suspend fun run2() {
+        inlineMeInner()
+    }
+    inline suspend fun inlineMeInner() {
+        StateMachineChecker.suspendHere()
+        StateMachineChecker.suspendHere()
+    }
+    // TODO: call it from run1
+    inline suspend fun inlineMeCapturing() {
+        c(); c()
+    }
+}
+
+inline fun inlineMe2(crossinline c: suspend () -> Unit) = inlineMe { c(); c() }
+
+inline fun inlineMe3(crossinline c: suspend () -> Unit) = object: SuspendRunnable {
+    override suspend fun run() {
+        var sr = inlineMe {
+            c()
+            c()
+        }
+        sr.run()
+        sr.run1()
+        sr.run2()
+    }
+
+    override suspend fun run1() {
+    }
+    override suspend fun run2() {
+    }
+}
+
+// FILE: A.java
+
+import test.InlineMeKt;
+import helpers.CoroutineUtilKt;
+import helpers.EmptyContinuation;
+import kotlin.Unit;
+
+public class A {
+    public static Object call() {
+        return InlineMeKt.inlineMe((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+    public static Object call2() {
+        return InlineMeKt.inlineMe2((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+    public static Object call3() {
+        return InlineMeKt.inlineMe3((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+}
+
+// FILE: box.kt
+
+import test.*
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+fun box(): String {
+    builder {
+        (A.call() as SuspendRunnable).run()
+    }
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call() as SuspendRunnable).run1()
+    }
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call() as SuspendRunnable).run2()
+    }
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call2() as SuspendRunnable).run()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call2() as SuspendRunnable).run1()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call2() as SuspendRunnable).run2()
+    }
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call3() as SuspendRunnable).run()
+    }
+    StateMachineChecker.check(10)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run1()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run2()
+    }
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe2 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run()
+    }
+    StateMachineChecker.check(8)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe2 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run1()
+    }
+    StateMachineChecker.check(8)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe2 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run2()
+    }
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe3 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run()
+    }
+    StateMachineChecker.check(18)
+
+    return "OK"
+}
\ No newline at end of file
--- /dev/null
+++ b/compiler/testData/codegen/box/coroutines/javaInterop/returnLambda.kt
@@ -0,0 +1,104 @@
+// IGNORE_BACKEND: JVM_IR
+// TARGET_BACKEND: JVM
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// NO_CHECK_LAMBDA_INLINING
+// CHECK_STATE_MACHINE
+
+// FILE: inlineMe.kt
+
+package test
+
+inline fun inlineMe(crossinline c: suspend () -> Unit) = suspend { c(); c() }
+
+inline fun inlineMe2(crossinline c: suspend () -> Unit) = inlineMe { c(); c() }
+
+inline fun inlineMe3(crossinline c: suspend () -> Unit) = suspend {
+    var sr = inlineMe {
+        c()
+        c()
+    }
+    sr()
+    sr = inlineMe {
+        c()
+        c()
+    }
+    sr()
+}
+
+// FILE: A.java
+
+import test.InlineMeKt;
+import helpers.CoroutineUtilKt;
+import helpers.EmptyContinuation;
+import kotlin.Unit;
+
+public class A {
+    public static Object call() {
+        return InlineMeKt.inlineMe((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+    public static Object call2() {
+        return InlineMeKt.inlineMe2((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+    public static Object call3() {
+        return InlineMeKt.inlineMe3((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+}
+
+// FILE: box.kt
+
+import test.*
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+fun box(): String {
+    builder {
+        (A.call() as (suspend () -> Unit))()
+    }
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call2() as (suspend () -> Unit))()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call3() as (suspend () -> Unit))()
+    }
+    StateMachineChecker.check(8)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe2 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }()
+    }
+    StateMachineChecker.check(8)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe3 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }()
+    }
+    StateMachineChecker.check(16)
+    return "OK"
+}
\ No newline at end of file
--- /dev/null
+++ b/compiler/testData/codegen/box/coroutines/javaInterop/returnObject.kt
@@ -0,0 +1,114 @@
+// IGNORE_BACKEND: JVM_IR
+// TARGET_BACKEND: JVM
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// NO_CHECK_LAMBDA_INLINING
+// CHECK_STATE_MACHINE
+
+// FILE: inlineMe.kt
+
+package test
+
+interface SuspendRunnable {
+    suspend fun run()
+}
+
+inline fun inlineMe(crossinline c: suspend () -> Unit) = object : SuspendRunnable {
+    override suspend fun run() {
+        c(); c()
+    }
+}
+
+inline fun inlineMe2(crossinline c: suspend () -> Unit) = inlineMe { c(); c() }
+
+inline fun inlineMe3(crossinline c: suspend () -> Unit) = object: SuspendRunnable {
+    override suspend fun run() {
+        var sr = inlineMe {
+            c()
+            c()
+        }
+        sr.run()
+        sr = inlineMe {
+            c()
+            c()
+        }
+        sr.run()
+    }
+}
+
+// FILE: A.java
+
+import test.InlineMeKt;
+import helpers.CoroutineUtilKt;
+import helpers.EmptyContinuation;
+import kotlin.Unit;
+
+public class A {
+    public static Object call() {
+        return InlineMeKt.inlineMe((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+    public static Object call2() {
+        return InlineMeKt.inlineMe2((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+    public static Object call3() {
+        return InlineMeKt.inlineMe3((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+}
+
+// FILE: box.kt
+
+import test.*
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+fun box(): String {
+    builder {
+        (A.call() as SuspendRunnable).run()
+    }
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call2() as SuspendRunnable).run()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call3() as SuspendRunnable).run()
+    }
+    StateMachineChecker.check(8)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe2 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run()
+    }
+    StateMachineChecker.check(8)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe3 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run()
+    }
+    StateMachineChecker.check(16)
+    return "OK"
+}
\ No newline at end of file
--- /dev/null
+++ b/compiler/testData/codegen/box/coroutines/javaInterop/severalCaptures.kt
@@ -0,0 +1,283 @@
+// IGNORE_BACKEND: JVM_IR
+// TARGET_BACKEND: JVM
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// CHECK_STATE_MACHINE
+
+// FILE: inlineMe.kt
+
+package test
+
+import helpers.*
+
+interface SuspendRunnable {
+    suspend fun run1()
+    suspend fun run2()
+}
+
+inline fun inlineMe(crossinline c1: suspend () -> Unit, crossinline c2: suspend () -> Unit) = object : SuspendRunnable {
+    override suspend fun run1() {
+        c1(); c1()
+    }
+    override suspend fun run2() {
+        c2(); c2()
+    }
+}
+
+inline fun inlineMe2(crossinline c1: suspend () -> Unit, crossinline c2: suspend () -> Unit) = inlineMe({ c1(); c1() }) { c2(); c2() }
+
+inline fun inlineMe3(crossinline c1: suspend () -> Unit, crossinline c2: suspend () -> Unit) = object : SuspendRunnable {
+    override suspend fun run1() {
+        val sr = inlineMe({ c1(); c1() }) { c2(); c2() }
+        sr.run1()
+        sr.run2()
+    }
+    override suspend fun run2() {
+        val sr = inlineMe2({ c1(); c1() }) { c2(); c2() }
+        sr.run1()
+        sr.run2()
+    }
+}
+
+inline fun inlineMe4(crossinline c1: suspend () -> Unit, crossinline c2: suspend () -> Unit) = object : SuspendRunnable {
+    override suspend fun run1() {
+        val sr = suspend {
+            c1();
+            c2()
+        }
+        sr()
+        sr()
+    }
+    override suspend fun run2() {
+        val sr = object : SuspendRunnable {
+            override suspend fun run1() {
+                c1(); c1()
+            }
+            override suspend fun run2() {
+                c2(); c2()
+            }
+        }
+        sr.run1()
+        sr.run2()
+    }
+}
+
+inline fun inlineMe5(crossinline c1: suspend () -> Unit) = inlineMe({ c1(); c1() }) {
+    StateMachineChecker.suspendHere()
+}
+
+// FILE: A.java
+
+import test.InlineMeKt;
+import helpers.CoroutineUtilKt;
+import helpers.EmptyContinuation;
+import kotlin.Unit;
+
+public class A {
+    public static Object call() {
+        return InlineMeKt.inlineMe((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation),
+            (continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+    public static Object call2() {
+        return InlineMeKt.inlineMe2((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation),
+            (continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+    public static Object call3() {
+        return InlineMeKt.inlineMe3((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation),
+            (continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+    public static Object call4() {
+        return InlineMeKt.inlineMe4((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation),
+            (continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+    public static Object call5() {
+        return InlineMeKt.inlineMe5((continuation) -> CoroutineUtilKt.getStateMachineChecker().suspendHere(continuation));
+    }
+}
+
+// FILE: box.kt
+
+import test.*
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+fun box(): String {
+    builder {
+        (A.call() as SuspendRunnable).run1()
+    }
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call() as SuspendRunnable).run2()
+    }
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call2() as SuspendRunnable).run1()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call2() as SuspendRunnable).run2()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call3() as SuspendRunnable).run1()
+    }
+    StateMachineChecker.check(8)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call3() as SuspendRunnable).run2()
+    }
+    StateMachineChecker.check(16)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call4() as SuspendRunnable).run1()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call4() as SuspendRunnable).run2()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call5() as SuspendRunnable).run1()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+
+    builder {
+        (A.call5() as SuspendRunnable).run2()
+    }
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe({
+                     StateMachineChecker.suspendHere()
+                     StateMachineChecker.suspendHere()
+                 }) {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run1()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe({
+                     StateMachineChecker.suspendHere()
+                     StateMachineChecker.suspendHere()
+                 }) {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run2()
+    }
+    StateMachineChecker.check(4)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe2 ({
+                       StateMachineChecker.suspendHere()
+                       StateMachineChecker.suspendHere()
+                   }) {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run1()
+    }
+    StateMachineChecker.check(8)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe2 ({
+                       StateMachineChecker.suspendHere()
+                       StateMachineChecker.suspendHere()
+                   }) {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run2()
+    }
+    StateMachineChecker.check(8)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe3 ({
+                       StateMachineChecker.suspendHere()
+                       StateMachineChecker.suspendHere()
+                   }) {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run1()
+    }
+    StateMachineChecker.check(16)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe3 ({
+                       StateMachineChecker.suspendHere()
+                       StateMachineChecker.suspendHere()
+                   }) {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run2()
+    }
+    StateMachineChecker.check(32)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe4 ({
+                       StateMachineChecker.suspendHere()
+                       StateMachineChecker.suspendHere()
+                   }) {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run1()
+    }
+    StateMachineChecker.check(8)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe4 ({
+                       StateMachineChecker.suspendHere()
+                       StateMachineChecker.suspendHere()
+                   }) {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run2()
+    }
+    StateMachineChecker.check(8)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe5 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run1()
+    }
+    StateMachineChecker.check(8)
+    StateMachineChecker.reset()
+
+    builder {
+        inlineMe5 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run2()
+    }
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    return "OK"
+}
\ No newline at end of file
--- a/compiler/testData/codegen/box/coroutines/tailCallOptimizations/crossinline.txt
+++ b/compiler/testData/codegen/box/coroutines/tailCallOptimizations/crossinline.txt
@@ -16,8 +16,8 @@
     public final @org.jetbrains.annotations.Nullable method invokeSuspend(@org.jetbrains.annotations.NotNull p0: java.lang.Object): java.lang.Object
 }
 
-@kotlin.coroutines.jvm.internal.DebugMetadata
 @kotlin.Metadata
+@kotlin.coroutines.jvm.internal.DebugMetadata
 public final class CrossinlineKt$box$1$filter$$inlined$source$1$lambda$1$1 {
     field L$0: java.lang.Object
     field L$1: java.lang.Object
@@ -40,6 +40,7 @@
     inner class CrossinlineKt$box$1$filter$$inlined$source$1$lambda$1$1
     public method <init>(p0: Sink, p1: CrossinlineKt$box$1$filter$$inlined$source$1): void
     public method close(@org.jetbrains.annotations.Nullable p0: java.lang.Throwable): void
+    public @org.jetbrains.annotations.Nullable method send$$forInline(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method send(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
 
@@ -50,11 +51,18 @@
     inner class CrossinlineKt$box$1$filter$$inlined$source$1
     inner class CrossinlineKt$box$1$filter$$inlined$source$1$1
     public method <init>(p0: SourceCrossinline, p1: kotlin.jvm.functions.Function1): void
+    public @org.jetbrains.annotations.Nullable method consume$$forInline(@org.jetbrains.annotations.NotNull p0: Sink, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method consume(@org.jetbrains.annotations.NotNull p0: Sink, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
 
 @kotlin.Metadata
+@kotlin.coroutines.jvm.internal.DebugMetadata
 public final class CrossinlineKt$box$1$fold$$inlined$consumeEach$1$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
+    field L$3: java.lang.Object
+    field L$4: java.lang.Object
     field label: int
     synthetic field result: java.lang.Object
     synthetic final field this$0: CrossinlineKt$box$1$fold$$inlined$consumeEach$1
@@ -72,11 +80,12 @@
     inner class CrossinlineKt$box$1$fold$$inlined$consumeEach$1$1
     public method <init>(p0: kotlin.jvm.internal.Ref$ObjectRef, p1: kotlin.jvm.functions.Function3): void
     public method close(@org.jetbrains.annotations.Nullable p0: java.lang.Throwable): void
+    public @org.jetbrains.annotations.Nullable method send$$forInline(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method send(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
 
-@kotlin.coroutines.jvm.internal.DebugMetadata
 @kotlin.Metadata
+@kotlin.coroutines.jvm.internal.DebugMetadata
 public final class CrossinlineKt$box$1$invokeSuspend$$inlined$filter$1$1 {
     field L$0: java.lang.Object
     field L$1: java.lang.Object
@@ -93,8 +102,8 @@
     public final @org.jetbrains.annotations.Nullable method invokeSuspend(@org.jetbrains.annotations.NotNull p0: java.lang.Object): java.lang.Object
 }
 
-@kotlin.coroutines.jvm.internal.DebugMetadata
 @kotlin.Metadata
+@kotlin.coroutines.jvm.internal.DebugMetadata
 public final class CrossinlineKt$box$1$invokeSuspend$$inlined$filter$1$2$1 {
     field L$0: java.lang.Object
     field L$1: java.lang.Object
@@ -130,10 +139,26 @@
 }
 
 @kotlin.Metadata
+public final class CrossinlineKt$box$1$invokeSuspend$$inlined$fold$1$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
+    field L$3: java.lang.Object
+    field L$4: java.lang.Object
+    field label: int
+    synthetic field result: java.lang.Object
+    synthetic final field this$0: CrossinlineKt$box$1$invokeSuspend$$inlined$fold$1
+    inner class CrossinlineKt$box$1$invokeSuspend$$inlined$fold$1
+    inner class CrossinlineKt$box$1$invokeSuspend$$inlined$fold$1$1
+    public method <init>(p0: CrossinlineKt$box$1$invokeSuspend$$inlined$fold$1, p1: kotlin.coroutines.Continuation): void
+    public final @org.jetbrains.annotations.Nullable method invokeSuspend(@org.jetbrains.annotations.NotNull p0: java.lang.Object): java.lang.Object
+}
+
+@kotlin.Metadata
 public final class CrossinlineKt$box$1$invokeSuspend$$inlined$fold$1 {
     synthetic final field $acc$inlined: kotlin.jvm.internal.Ref$ObjectRef
-    inner class CrossinlineKt$box$1$fold$$inlined$consumeEach$1$1
     inner class CrossinlineKt$box$1$invokeSuspend$$inlined$fold$1
+    inner class CrossinlineKt$box$1$invokeSuspend$$inlined$fold$1$1
     public method <init>(p0: kotlin.jvm.internal.Ref$ObjectRef): void
     public method close(@org.jetbrains.annotations.Nullable p0: java.lang.Throwable): void
     public @org.jetbrains.annotations.Nullable method send(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
@@ -174,6 +199,7 @@
     inner class CrossinlineKt$consumeEach$2$send$1
     public method <init>(p0: kotlin.jvm.functions.Function2): void
     public method close(@org.jetbrains.annotations.Nullable p0: java.lang.Throwable): void
+    public @org.jetbrains.annotations.Nullable method send$$forInline(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method send(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
 
@@ -195,8 +221,8 @@
     public final @org.jetbrains.annotations.Nullable method invokeSuspend(@org.jetbrains.annotations.NotNull p0: java.lang.Object): java.lang.Object
 }
 
-@kotlin.coroutines.jvm.internal.DebugMetadata
 @kotlin.Metadata
+@kotlin.coroutines.jvm.internal.DebugMetadata
 public final class CrossinlineKt$filter$$inlined$source$1$lambda$1$1 {
     field L$0: java.lang.Object
     field L$1: java.lang.Object
@@ -219,6 +245,7 @@
     inner class CrossinlineKt$filter$$inlined$source$1$lambda$1$1
     public method <init>(p0: Sink, p1: CrossinlineKt$filter$$inlined$source$1): void
     public method close(@org.jetbrains.annotations.Nullable p0: java.lang.Throwable): void
+    public @org.jetbrains.annotations.Nullable method send$$forInline(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method send(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
 
@@ -229,11 +256,18 @@
     inner class CrossinlineKt$filter$$inlined$source$1
     inner class CrossinlineKt$filter$$inlined$source$1$1
     public method <init>(p0: SourceCrossinline, p1: kotlin.jvm.functions.Function1): void
+    public @org.jetbrains.annotations.Nullable method consume$$forInline(@org.jetbrains.annotations.NotNull p0: Sink, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method consume(@org.jetbrains.annotations.NotNull p0: Sink, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
 
 @kotlin.Metadata
+@kotlin.coroutines.jvm.internal.DebugMetadata
 public final class CrossinlineKt$fold$$inlined$consumeEach$1$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
+    field L$3: java.lang.Object
+    field L$4: java.lang.Object
     field label: int
     synthetic field result: java.lang.Object
     synthetic final field this$0: CrossinlineKt$fold$$inlined$consumeEach$1
@@ -251,6 +285,7 @@
     inner class CrossinlineKt$fold$$inlined$consumeEach$1$1
     public method <init>(p0: kotlin.jvm.internal.Ref$ObjectRef, p1: kotlin.jvm.functions.Function3): void
     public method close(@org.jetbrains.annotations.Nullable p0: java.lang.Throwable): void
+    public @org.jetbrains.annotations.Nullable method send$$forInline(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method send(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
 
@@ -284,7 +319,11 @@
 }
 
 @kotlin.Metadata
+@kotlin.coroutines.jvm.internal.DebugMetadata
 public final class CrossinlineKt$source$1$consume$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
     field label: int
     synthetic field result: java.lang.Object
     synthetic final field this$0: CrossinlineKt$source$1
@@ -300,6 +339,7 @@
     inner class CrossinlineKt$source$1
     inner class CrossinlineKt$source$1$consume$1
     public method <init>(p0: kotlin.jvm.functions.Function2): void
+    public @org.jetbrains.annotations.Nullable method consume$$forInline(@org.jetbrains.annotations.NotNull p0: Sink, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method consume(@org.jetbrains.annotations.NotNull p0: Sink, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
 
--- a/compiler/testData/codegen/box/coroutines/tailCallOptimizations/crossinline_1_2.txt
+++ b/compiler/testData/codegen/box/coroutines/tailCallOptimizations/crossinline_1_2.txt
@@ -55,10 +55,28 @@
 }
 
 @kotlin.Metadata
+public final class CrossinlineKt$box$1$doResume$$inlined$fold$1$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
+    field L$3: java.lang.Object
+    field L$4: java.lang.Object
+    synthetic field data: java.lang.Object
+    synthetic field exception: java.lang.Throwable
+    synthetic final field this$0: CrossinlineKt$box$1$doResume$$inlined$fold$1
+    inner class CrossinlineKt$box$1$doResume$$inlined$fold$1
+    inner class CrossinlineKt$box$1$doResume$$inlined$fold$1$1
+    public method <init>(p0: CrossinlineKt$box$1$doResume$$inlined$fold$1, p1: kotlin.coroutines.experimental.Continuation): void
+    public final @org.jetbrains.annotations.Nullable method doResume(@org.jetbrains.annotations.Nullable p0: java.lang.Object, @org.jetbrains.annotations.Nullable p1: java.lang.Throwable): java.lang.Object
+    synthetic final method getLabel(): int
+    synthetic final method setLabel(p0: int): void
+}
+
+@kotlin.Metadata
 public final class CrossinlineKt$box$1$doResume$$inlined$fold$1 {
     synthetic final field $acc$inlined: kotlin.jvm.internal.Ref$ObjectRef
     inner class CrossinlineKt$box$1$doResume$$inlined$fold$1
-    inner class CrossinlineKt$box$1$fold$$inlined$consumeEach$1$1
+    inner class CrossinlineKt$box$1$doResume$$inlined$fold$1$1
     public method <init>(p0: kotlin.jvm.internal.Ref$ObjectRef): void
     public method close(@org.jetbrains.annotations.Nullable p0: java.lang.Throwable): void
     public @org.jetbrains.annotations.Nullable method send(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
@@ -108,6 +126,7 @@
     inner class CrossinlineKt$box$1$filter$$inlined$source$1$lambda$1$1
     public method <init>(p0: Sink, p1: CrossinlineKt$box$1$filter$$inlined$source$1): void
     public method close(@org.jetbrains.annotations.Nullable p0: java.lang.Throwable): void
+    public @org.jetbrains.annotations.Nullable method send$$forInline(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method send(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
@@ -118,11 +137,17 @@
     inner class CrossinlineKt$box$1$filter$$inlined$source$1
     inner class CrossinlineKt$box$1$filter$$inlined$source$1$1
     public method <init>(p0: SourceCrossinline, p1: kotlin.jvm.functions.Function1): void
+    public @org.jetbrains.annotations.Nullable method consume$$forInline(@org.jetbrains.annotations.NotNull p0: Sink, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method consume(@org.jetbrains.annotations.NotNull p0: Sink, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
 @kotlin.Metadata
 public final class CrossinlineKt$box$1$fold$$inlined$consumeEach$1$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
+    field L$3: java.lang.Object
+    field L$4: java.lang.Object
     synthetic field data: java.lang.Object
     synthetic field exception: java.lang.Throwable
     synthetic final field this$0: CrossinlineKt$box$1$fold$$inlined$consumeEach$1
@@ -142,6 +167,7 @@
     inner class CrossinlineKt$box$1$fold$$inlined$consumeEach$1$1
     public method <init>(p0: kotlin.jvm.internal.Ref$ObjectRef, p1: kotlin.jvm.functions.Function3): void
     public method close(@org.jetbrains.annotations.Nullable p0: java.lang.Throwable): void
+    public @org.jetbrains.annotations.Nullable method send$$forInline(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method send(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
@@ -180,6 +206,7 @@
     inner class CrossinlineKt$consumeEach$2$send$1
     public method <init>(p0: kotlin.jvm.functions.Function2): void
     public method close(@org.jetbrains.annotations.Nullable p0: java.lang.Throwable): void
+    public @org.jetbrains.annotations.Nullable method send$$forInline(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method send(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
@@ -227,6 +254,7 @@
     inner class CrossinlineKt$filter$$inlined$source$1$lambda$1$1
     public method <init>(p0: Sink, p1: CrossinlineKt$filter$$inlined$source$1): void
     public method close(@org.jetbrains.annotations.Nullable p0: java.lang.Throwable): void
+    public @org.jetbrains.annotations.Nullable method send$$forInline(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method send(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
@@ -237,11 +265,17 @@
     inner class CrossinlineKt$filter$$inlined$source$1
     inner class CrossinlineKt$filter$$inlined$source$1$1
     public method <init>(p0: SourceCrossinline, p1: kotlin.jvm.functions.Function1): void
+    public @org.jetbrains.annotations.Nullable method consume$$forInline(@org.jetbrains.annotations.NotNull p0: Sink, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method consume(@org.jetbrains.annotations.NotNull p0: Sink, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
 @kotlin.Metadata
 public final class CrossinlineKt$fold$$inlined$consumeEach$1$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
+    field L$3: java.lang.Object
+    field L$4: java.lang.Object
     synthetic field data: java.lang.Object
     synthetic field exception: java.lang.Throwable
     synthetic final field this$0: CrossinlineKt$fold$$inlined$consumeEach$1
@@ -261,6 +295,7 @@
     inner class CrossinlineKt$fold$$inlined$consumeEach$1$1
     public method <init>(p0: kotlin.jvm.internal.Ref$ObjectRef, p1: kotlin.jvm.functions.Function3): void
     public method close(@org.jetbrains.annotations.Nullable p0: java.lang.Throwable): void
+    public @org.jetbrains.annotations.Nullable method send$$forInline(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method send(p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
@@ -296,6 +331,9 @@
 
 @kotlin.Metadata
 public final class CrossinlineKt$source$1$consume$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
     synthetic field data: java.lang.Object
     synthetic field exception: java.lang.Throwable
     synthetic final field this$0: CrossinlineKt$source$1
@@ -313,6 +351,7 @@
     inner class CrossinlineKt$source$1
     inner class CrossinlineKt$source$1$consume$1
     public method <init>(p0: kotlin.jvm.functions.Function2): void
+    public @org.jetbrains.annotations.Nullable method consume$$forInline(@org.jetbrains.annotations.NotNull p0: Sink, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method consume(@org.jetbrains.annotations.NotNull p0: Sink, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
--- a/compiler/testData/codegen/box/coroutines/tailCallOptimizations/epam.txt
+++ b/compiler/testData/codegen/box/coroutines/tailCallOptimizations/epam.txt
@@ -1,8 +1,10 @@
+@kotlin.coroutines.jvm.internal.DebugMetadata
 @kotlin.Metadata
 public final class EpamKt$box$1$invokeSuspend$$inlined$zip$1 {
     synthetic final field $source1: MyDeferred
     synthetic final field $source2: MyDeferred
     field L$0: java.lang.Object
+    field L$1: java.lang.Object
     field label: int
     inner class EpamKt$box$1$invokeSuspend$$inlined$zip$1
     public method <init>(p0: MyDeferred, p1: MyDeferred, p2: kotlin.coroutines.Continuation): void
@@ -48,16 +50,20 @@
     public final @org.jetbrains.annotations.Nullable method invokeSuspend(@org.jetbrains.annotations.NotNull p0: java.lang.Object): java.lang.Object
 }
 
+@kotlin.coroutines.jvm.internal.DebugMetadata
 @kotlin.Metadata
 public final class EpamKt$zip$1 {
     synthetic final field $source1: MyDeferred
     synthetic final field $source2: MyDeferred
     synthetic final field $zipper: kotlin.jvm.functions.Function2
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
     field label: int
     inner class EpamKt$zip$1
     public method <init>(p0: kotlin.jvm.functions.Function2, p1: MyDeferred, p2: MyDeferred, p3: kotlin.coroutines.Continuation): void
     public final @org.jetbrains.annotations.NotNull method create(@org.jetbrains.annotations.NotNull p0: kotlin.coroutines.Continuation): kotlin.coroutines.Continuation
     public final method invoke(p0: java.lang.Object): java.lang.Object
+    public final @org.jetbrains.annotations.Nullable method invokeSuspend$$forInline(@org.jetbrains.annotations.NotNull p0: java.lang.Object): java.lang.Object
     public final @org.jetbrains.annotations.Nullable method invokeSuspend(@org.jetbrains.annotations.NotNull p0: java.lang.Object): java.lang.Object
 }
 
--- a/compiler/testData/codegen/box/coroutines/tailCallOptimizations/epam_1_2.txt
+++ b/compiler/testData/codegen/box/coroutines/tailCallOptimizations/epam_1_2.txt
@@ -3,6 +3,7 @@
     synthetic final field $source1: MyDeferred
     synthetic final field $source2: MyDeferred
     field L$0: java.lang.Object
+    field L$1: java.lang.Object
     inner class EpamKt$box$1$doResume$$inlined$zip$1
     public method <init>(p0: MyDeferred, p1: MyDeferred, p2: kotlin.coroutines.experimental.Continuation): void
     public final @org.jetbrains.annotations.NotNull method create(@org.jetbrains.annotations.NotNull p0: kotlin.coroutines.experimental.Continuation): kotlin.coroutines.experimental.Continuation
@@ -46,9 +47,12 @@
     synthetic final field $source1: MyDeferred
     synthetic final field $source2: MyDeferred
     synthetic final field $zipper: kotlin.jvm.functions.Function2
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
     inner class EpamKt$zip$1
     public method <init>(p0: kotlin.jvm.functions.Function2, p1: MyDeferred, p2: MyDeferred, p3: kotlin.coroutines.experimental.Continuation): void
     public final @org.jetbrains.annotations.NotNull method create(@org.jetbrains.annotations.NotNull p0: kotlin.coroutines.experimental.Continuation): kotlin.coroutines.experimental.Continuation
+    public final @org.jetbrains.annotations.Nullable method doResume$$forInline(@org.jetbrains.annotations.Nullable p0: java.lang.Object, @org.jetbrains.annotations.Nullable p1: java.lang.Throwable): java.lang.Object
     public final @org.jetbrains.annotations.Nullable method doResume(@org.jetbrains.annotations.Nullable p0: java.lang.Object, @org.jetbrains.annotations.Nullable p1: java.lang.Throwable): java.lang.Object
     public final method invoke(p0: java.lang.Object): java.lang.Object
 }
--- a/compiler/testData/codegen/box/coroutines/tailCallOptimizations/innerObjectRetransformation.txt
+++ b/compiler/testData/codegen/box/coroutines/tailCallOptimizations/innerObjectRetransformation.txt
@@ -63,10 +63,25 @@
 }
 
 @kotlin.Metadata
+public final class flow/InnerObjectRetransformationKt$check$$inlined$flowWith$1$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
+    field L$3: java.lang.Object
+    field label: int
+    synthetic field result: java.lang.Object
+    synthetic final field this$0: flow.InnerObjectRetransformationKt$check$$inlined$flowWith$1
+    inner class flow/InnerObjectRetransformationKt$check$$inlined$flowWith$1
+    inner class flow/InnerObjectRetransformationKt$check$$inlined$flowWith$1$1
+    public method <init>(p0: flow.InnerObjectRetransformationKt$check$$inlined$flowWith$1, p1: kotlin.coroutines.Continuation): void
+    public final @org.jetbrains.annotations.Nullable method invokeSuspend(@org.jetbrains.annotations.NotNull p0: java.lang.Object): java.lang.Object
+}
+
+@kotlin.Metadata
 public final class flow/InnerObjectRetransformationKt$check$$inlined$flowWith$1 {
     synthetic final field $this_flowWith$inlined: flow.Flow
     inner class flow/InnerObjectRetransformationKt$check$$inlined$flowWith$1
-    inner class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$2$1
+    inner class flow/InnerObjectRetransformationKt$check$$inlined$flowWith$1$1
     public method <init>(p0: flow.Flow): void
     public @org.jetbrains.annotations.Nullable method collect(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
@@ -99,6 +114,7 @@
     inner class flow/InnerObjectRetransformationKt$collect$2
     inner class flow/InnerObjectRetransformationKt$collect$2$emit$1
     public method <init>(p0: kotlin.jvm.functions.Function2): void
+    public @org.jetbrains.annotations.Nullable method emit$$forInline(@org.jetbrains.annotations.NotNull p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method emit(@org.jetbrains.annotations.NotNull p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
 
@@ -119,11 +135,17 @@
     inner class flow/InnerObjectRetransformationKt$flow$1
     inner class flow/InnerObjectRetransformationKt$flow$1$collect$1
     public method <init>(p0: kotlin.jvm.functions.Function2): void
+    public @org.jetbrains.annotations.Nullable method collect$$forInline(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method collect(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
 
 @kotlin.Metadata
+@kotlin.coroutines.jvm.internal.DebugMetadata
 public final class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$1$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
+    field L$3: java.lang.Object
     field label: int
     synthetic field result: java.lang.Object
     synthetic final field this$0: flow.InnerObjectRetransformationKt$flowWith$$inlined$flow$1
@@ -140,11 +162,17 @@
     inner class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$1
     inner class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$1$1
     public method <init>(p0: flow.Flow, p1: kotlin.jvm.functions.Function2): void
+    public @org.jetbrains.annotations.Nullable method collect$$forInline(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method collect(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
 
 @kotlin.Metadata
+@kotlin.coroutines.jvm.internal.DebugMetadata
 public final class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$2$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
+    field L$3: java.lang.Object
     field label: int
     synthetic field result: java.lang.Object
     synthetic final field this$0: flow.InnerObjectRetransformationKt$flowWith$$inlined$flow$2
@@ -161,6 +189,7 @@
     inner class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$2
     inner class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$2$1
     public method <init>(p0: flow.Flow, p1: kotlin.jvm.functions.Function2): void
+    public @org.jetbrains.annotations.Nullable method collect$$forInline(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method collect(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.Continuation): java.lang.Object
 }
 
--- a/compiler/testData/codegen/box/coroutines/tailCallOptimizations/innerObjectRetransformation_1_2.txt
+++ b/compiler/testData/codegen/box/coroutines/tailCallOptimizations/innerObjectRetransformation_1_2.txt
@@ -64,10 +64,27 @@
 }
 
 @kotlin.Metadata
+public final class flow/InnerObjectRetransformationKt$check$$inlined$flowWith$1$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
+    field L$3: java.lang.Object
+    synthetic field data: java.lang.Object
+    synthetic field exception: java.lang.Throwable
+    synthetic final field this$0: flow.InnerObjectRetransformationKt$check$$inlined$flowWith$1
+    inner class flow/InnerObjectRetransformationKt$check$$inlined$flowWith$1
+    inner class flow/InnerObjectRetransformationKt$check$$inlined$flowWith$1$1
+    public method <init>(p0: flow.InnerObjectRetransformationKt$check$$inlined$flowWith$1, p1: kotlin.coroutines.experimental.Continuation): void
+    public final @org.jetbrains.annotations.Nullable method doResume(@org.jetbrains.annotations.Nullable p0: java.lang.Object, @org.jetbrains.annotations.Nullable p1: java.lang.Throwable): java.lang.Object
+    synthetic final method getLabel(): int
+    synthetic final method setLabel(p0: int): void
+}
+
+@kotlin.Metadata
 public final class flow/InnerObjectRetransformationKt$check$$inlined$flowWith$1 {
     synthetic final field $this_flowWith$inlined: flow.Flow
     inner class flow/InnerObjectRetransformationKt$check$$inlined$flowWith$1
-    inner class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$2$1
+    inner class flow/InnerObjectRetransformationKt$check$$inlined$flowWith$1$1
     public method <init>(p0: flow.Flow): void
     public @org.jetbrains.annotations.Nullable method collect(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
@@ -103,6 +120,7 @@
     inner class flow/InnerObjectRetransformationKt$collect$2
     inner class flow/InnerObjectRetransformationKt$collect$2$emit$1
     public method <init>(p0: kotlin.jvm.functions.Function2): void
+    public @org.jetbrains.annotations.Nullable method emit$$forInline(@org.jetbrains.annotations.NotNull p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method emit(@org.jetbrains.annotations.NotNull p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
@@ -125,11 +143,16 @@
     inner class flow/InnerObjectRetransformationKt$flow$1
     inner class flow/InnerObjectRetransformationKt$flow$1$collect$1
     public method <init>(p0: kotlin.jvm.functions.Function2): void
+    public @org.jetbrains.annotations.Nullable method collect$$forInline(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method collect(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
 @kotlin.Metadata
 public final class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$1$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
+    field L$3: java.lang.Object
     synthetic field data: java.lang.Object
     synthetic field exception: java.lang.Throwable
     synthetic final field this$0: flow.InnerObjectRetransformationKt$flowWith$$inlined$flow$1
@@ -148,11 +171,16 @@
     inner class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$1
     inner class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$1$1
     public method <init>(p0: flow.Flow, p1: kotlin.jvm.functions.Function2): void
+    public @org.jetbrains.annotations.Nullable method collect$$forInline(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method collect(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
 @kotlin.Metadata
 public final class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$2$1 {
+    field L$0: java.lang.Object
+    field L$1: java.lang.Object
+    field L$2: java.lang.Object
+    field L$3: java.lang.Object
     synthetic field data: java.lang.Object
     synthetic field exception: java.lang.Throwable
     synthetic final field this$0: flow.InnerObjectRetransformationKt$flowWith$$inlined$flow$2
@@ -171,6 +199,7 @@
     inner class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$2
     inner class flow/InnerObjectRetransformationKt$flowWith$$inlined$flow$2$1
     public method <init>(p0: flow.Flow, p1: kotlin.jvm.functions.Function2): void
+    public @org.jetbrains.annotations.Nullable method collect$$forInline(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
     public @org.jetbrains.annotations.Nullable method collect(@org.jetbrains.annotations.NotNull p0: flow.FlowCollector, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
--- /dev/null
+++ b/compiler/testData/codegen/boxInline/suspend/nonSuspendCrossinline.kt
@@ -0,0 +1,64 @@
+// IGNORE_BACKEND: JVM_IR
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// CHECK_STATE_MACHINE
+
+// FILE: inline.kt
+
+class MyDeferred<T>(val t: suspend () -> T) {
+    suspend fun await() = t()
+}
+
+fun <T> async(block: suspend () -> T) = MyDeferred(block)
+
+inline fun <T, R> map(source: MyDeferred<T>, crossinline mapper: (T) -> R) =
+    async {
+        mapper(source.await())
+    }
+
+inline fun <T, R1, R2> map2(source: MyDeferred<T>, crossinline mapper1: (T) -> R1, crossinline mapper2: (R1) -> R2) =
+    async {
+        val c = suspend {
+            mapper1(source.await())
+        }
+        mapper2(c())
+    }
+
+inline fun <T, R1, R2, R3> map3(source: MyDeferred<T>, crossinline mapper1: (T) -> R1, crossinline mapper2: (R1) -> R2, crossinline mapper3: (R2) -> R3) =
+    async {
+        val c = suspend {
+            val c = suspend {
+                mapper1(source.await())
+            }
+            mapper2(c())
+        }
+        mapper3(c())
+    }
+
+// FILE: box.kt
+
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(EmptyContinuation)
+}
+
+fun box(): String {
+    val source = MyDeferred { 1 }
+    var result = -1
+    builder {
+        result = map(source) { it + 2 }.await()
+    }
+    if (result != 3) return "FAIL 1 $result"
+    builder {
+        result = map2(source, { it + 2 }, { it + 3 }).await()
+    }
+    if (result != 6) return "FAIL 2 $result"
+    builder {
+        result = map3(source, { it + 2 }, { it + 3 }, { it + 4 }).await()
+    }
+    if (result != 10) return "FAIL 3 $result"
+    return "OK"
+}
\ No newline at end of file
--- /dev/null
+++ b/compiler/testData/codegen/boxInline/suspend/stateMachine/crossingCoroutineBoundaries.kt
@@ -0,0 +1,61 @@
+// IGNORE_BACKEND: JVM_IR
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// CHECK_STATE_MACHINE
+
+// FILE: inline.kt
+
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+interface SuspendRunnable {
+    suspend fun run()
+}
+
+fun runSuspend(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+inline suspend fun inlineMe(crossinline c1: suspend () -> Unit) {
+    object : SuspendRunnable {
+        override suspend fun run() {
+            c1()
+        }
+    }.run()
+
+    StateMachineChecker.check(2)
+    StateMachineChecker.reset()
+
+    runSuspend {
+        object : SuspendRunnable {
+            override suspend fun run() {
+                StateMachineChecker.suspendHere()
+                StateMachineChecker.suspendHere()
+            }
+        }.run()
+
+        StateMachineChecker.check(2)
+    }
+}
+
+
+// FILE: box.kt
+// COMMON_COROUTINES_TEST
+
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+fun box(): String {
+    builder {
+        inlineMe {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }
+    }
+    return "OK"
+}
--- /dev/null
+++ b/compiler/testData/codegen/boxInline/suspend/stateMachine/independentInline.kt
@@ -0,0 +1,69 @@
+// IGNORE_BACKEND: JVM_IR
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// CHECK_STATE_MACHINE
+
+// FILE: inline.kt
+
+import helpers.*
+
+interface SuspendRunnable {
+    suspend fun run()
+    suspend fun ownIndependentInline()
+}
+
+inline fun inlineMe(crossinline c1: suspend () -> Unit) =
+    object : SuspendRunnable {
+        override suspend fun run() {
+            c1()
+            c1()
+        }
+
+        override suspend fun ownIndependentInline() {
+            inlineMe2 {
+                StateMachineChecker.suspendHere()
+                StateMachineChecker.suspendHere()
+            }.ownIndependentInline()
+        }
+    }
+
+
+inline fun inlineMe2(crossinline c2: suspend () -> Unit): SuspendRunnable =
+    object : SuspendRunnable {
+        override suspend fun run() {
+        }
+
+        override suspend fun ownIndependentInline() {
+            c2()
+            c2()
+        }
+    }
+
+// FILE: box.kt
+// COMMON_COROUTINES_TEST
+
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+fun box(): String {
+    val r = inlineMe {
+        StateMachineChecker.suspendHere()
+        StateMachineChecker.suspendHere()
+    }
+
+    builder {
+        r.run()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    StateMachineChecker.reset()
+    builder {
+        r.ownIndependentInline()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    return "OK"
+}
\ No newline at end of file
--- /dev/null
+++ b/compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectRetransformation.kt
@@ -0,0 +1,79 @@
+// IGNORE_BACKEND: JVM_IR
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// CHECK_STATE_MACHINE
+
+// In this test the following transformation are occuring:
+//   flow$1 -> flowWith$$inlined$flow$1
+//   flow$1 -> check$$inlined$flow$1
+//   flow$1 -> flowWith$$inlined$flow$2
+//   flowWith$$inlined$flow$2 -> check$$inlined$flowWith$1
+
+// All thansformations, except the third, shall generate state-machine.
+// The third shall not generate state-machine, since it is retransformed.
+
+// FILE: inline.kt
+package flow
+
+interface FlowCollector<T> {
+    suspend fun emit(value: T)
+}
+
+interface Flow<T : Any> {
+    suspend fun collect(collector: FlowCollector<T>)
+}
+
+public inline fun <T : Any> flow(crossinline block: suspend FlowCollector<T>.() -> Unit) = object : Flow<T> {
+    override suspend fun collect(collector: FlowCollector<T>) {
+        collector.block()
+        collector.block()
+    }
+}
+
+suspend inline fun <T : Any> Flow<T>.collect(crossinline action: suspend (T) -> Unit) {
+    collect(object : FlowCollector<T> {
+        override suspend fun emit(value: T) {
+            action(value)
+            action(value)
+        }
+    })
+}
+
+inline fun <T : Any, R : Any> Flow<T>.flowWith(crossinline builderBlock: suspend Flow<T>.() -> Flow<R>): Flow<T> =
+    flow {
+        builderBlock()
+        builderBlock()
+    }
+
+// FILE: box.kt
+// COMMON_COROUTINES_TEST
+
+import flow.*
+
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+suspend fun check() {
+    val f: Unit = flow<Int> {
+        emit(1)
+    }.flowWith {
+        StateMachineChecker.suspendHere()
+        StateMachineChecker.suspendHere()
+        this
+    }.collect {
+        // In this test collect is just terminating operation, which just runs the lazy computations
+    }
+}
+
+fun box(): String {
+    builder {
+        check()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 8)
+    return "OK"
+}
--- /dev/null
+++ b/compiler/testData/codegen/boxInline/suspend/stateMachine/insideObject.kt
@@ -0,0 +1,48 @@
+// IGNORE_BACKEND: JVM_IR
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// CHECK_STATE_MACHINE
+
+// FILE: inline.kt
+
+import helpers.*
+
+interface SuspendRunnable {
+    suspend fun run()
+}
+
+class R : SuspendRunnable {
+    override suspend fun run() {
+        val sr: SuspendRunnable = inlineMe2 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }
+        sr.run()
+    }
+
+    inline fun inlineMe2(crossinline c: suspend () -> Unit) = object : SuspendRunnable {
+        override suspend fun run() {
+            c()
+            c()
+        }
+    }
+}
+
+// FILE: box.kt
+// COMMON_COROUTINES_TEST
+
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+fun box(): String {
+    builder {
+        R().run()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    return "OK"
+}
--- /dev/null
+++ b/compiler/testData/codegen/boxInline/suspend/stateMachine/objectInsideLambdas.kt
@@ -0,0 +1,44 @@
+// IGNORE_BACKEND: JVM_IR
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// CHECK_STATE_MACHINE
+
+// FILE: inline.kt
+
+interface SuspendRunnable {
+    suspend fun run()
+}
+
+inline fun inlineMe(crossinline c: suspend () -> Unit) = {
+    {
+        val sr: SuspendRunnable = object : SuspendRunnable {
+            override suspend fun run() {
+                c()
+                c()
+            }
+        }
+        sr
+    }()
+}()
+
+// FILE: box.kt
+// COMMON_COROUTINES_TEST
+
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+fun box(): String {
+    builder {
+        inlineMe {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }.run()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    return "OK"
+}
--- /dev/null
+++ b/compiler/testData/codegen/boxInline/suspend/stateMachine/oneInlineTwoCaptures.kt
@@ -0,0 +1,57 @@
+// IGNORE_BACKEND: JVM_IR
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// CHECK_STATE_MACHINE
+
+// FILE: inline.kt
+
+interface SuspendRunnable {
+    suspend fun run()
+    suspend fun run2()
+}
+
+inline fun inlineMe(crossinline c: suspend () -> Unit, crossinline c2: suspend () -> Unit) =
+    object : SuspendRunnable {
+        override suspend fun run() {
+            c()
+            c()
+        }
+
+        override suspend fun run2() {
+            c2()
+            c2()
+        }
+    }
+
+// FILE: box.kt
+// COMMON_COROUTINES_TEST
+
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+fun box(): String {
+    val r = inlineMe(
+        {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }
+    ) {
+        StateMachineChecker.suspendHere()
+        StateMachineChecker.suspendHere()
+    }
+    builder {
+        r.run()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    StateMachineChecker.reset()
+    builder {
+        r.run2()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    return "OK"
+}
--- /dev/null
+++ b/compiler/testData/codegen/boxInline/suspend/stateMachine/passLambda.kt
@@ -0,0 +1,150 @@
+// IGNORE_BACKEND: JVM_IR
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// NO_CHECK_LAMBDA_INLINING
+// CHECK_STATE_MACHINE
+
+// FILE: inline.kt
+
+import helpers.*
+
+interface SuspendRunnable {
+    suspend fun run()
+}
+
+inline fun inlineMe1(crossinline c: suspend () -> Unit) =
+    object : SuspendRunnable {
+        override suspend fun run() {
+            c()
+            c()
+        }
+    }
+
+inline fun inlineMe2(crossinline c: suspend () -> Unit) = suspend {
+    c()
+    c()
+}
+
+inline suspend fun inlineMe3(crossinline c: suspend () -> Unit) {
+    c()
+    c()
+}
+
+inline suspend fun inlineMe4(c: suspend () -> Unit) {
+    c()
+    c()
+}
+
+inline fun inlineMe5(noinline c: suspend () -> Unit) =
+    object : SuspendRunnable {
+        override suspend fun run() {
+            c()
+            c()
+        }
+    }
+
+inline fun inlineMe6(noinline c: suspend () -> Unit) = suspend {
+    c()
+    c()
+}
+
+inline suspend fun inlineMe7(noinline c: suspend () -> Unit) {
+    c()
+    c()
+}
+
+inline fun inlineMe11(crossinline c: suspend () -> Unit) = inlineMe1(c)
+inline fun inlineMe12(crossinline c: suspend () -> Unit) = inlineMe2(c)
+inline suspend fun inlineMe13(crossinline c: suspend () -> Unit) = inlineMe3(c)
+inline suspend fun inlineMe14(crossinline c: suspend () -> Unit) = inlineMe4(c)
+
+// FILE: box.kt
+// COMMON_COROUTINES_TEST
+
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+fun box(): String {
+    val lambda = suspend {
+        StateMachineChecker.suspendHere()
+        StateMachineChecker.suspendHere()
+    }
+
+    builder {
+        val r = inlineMe1(lambda)
+        r.run()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe2(lambda)()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe3(lambda)
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe4(lambda)
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    StateMachineChecker.reset()
+    builder {
+        val r = inlineMe5(lambda)
+        r.run()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe6(lambda)()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe7(lambda)
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+
+    StateMachineChecker.reset()
+    builder {
+        val r = inlineMe11 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }
+        r.run()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe12 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe13 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+    StateMachineChecker.reset()
+    builder {
+        inlineMe14 {
+            StateMachineChecker.suspendHere()
+            StateMachineChecker.suspendHere()
+        }
+    }
+    StateMachineChecker.check(numberOfSuspensions = 4)
+
+    return "OK"
+}
\ No newline at end of file
--- /dev/null
+++ b/compiler/testData/codegen/boxInline/suspend/stateMachine/passParameter.kt
@@ -0,0 +1,60 @@
+// IGNORE_BACKEND: JVM_IR
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// CHECK_STATE_MACHINE
+
+// FILE: inline.kt
+
+import helpers.*
+
+interface SuspendRunnable {
+    suspend fun run()
+    suspend fun run2()
+}
+
+inline fun inlineMe(crossinline c1: suspend () -> Unit, crossinline c2: suspend () -> Unit) =
+    object : SuspendRunnable {
+        override suspend fun run() {
+            c1() // TODO: Double this call, when suspend markers are generated for inline and crossinline lambdas
+        }
+
+        override suspend fun run2() {
+            c2()
+        }
+    }
+
+
+inline fun inlineMe2(crossinline c1: suspend () -> Unit) =
+    inlineMe(c1) {
+        StateMachineChecker.suspendHere()
+        StateMachineChecker.suspendHere()
+    }
+
+// FILE: box.kt
+// COMMON_COROUTINES_TEST
+
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+fun box(): String {
+    val r = inlineMe2 {
+        StateMachineChecker.suspendHere()
+        StateMachineChecker.suspendHere()
+    }
+
+    builder {
+        r.run()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 2)
+    StateMachineChecker.reset()
+    builder {
+        r.run2()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 2)
+    return "OK"
+}
--- /dev/null
+++ b/compiler/testData/codegen/boxInline/suspend/stateMachine/passParameterLambda.kt
@@ -0,0 +1,36 @@
+// IGNORE_BACKEND: JVM_IR
+// COMMON_COROUTINES_TEST
+// WITH_RUNTIME
+// WITH_COROUTINES
+// CHECK_STATE_MACHINE
+
+// FILE: inline.kt
+
+import helpers.*
+
+inline fun inlineMe(crossinline c: suspend () -> Unit) = suspend { c(); c() }
+
+inline fun inlineMe2(crossinline c: suspend () -> Unit) = inlineMe { c(); c() }
+
+// FILE: box.kt
+// COMMON_COROUTINES_TEST
+
+import helpers.*
+import COROUTINES_PACKAGE.*
+
+fun builder(c: suspend () -> Unit) {
+    c.startCoroutine(CheckStateMachineContinuation)
+}
+
+fun box(): String {
+    val r = inlineMe2 {
+        StateMachineChecker.suspendHere()
+        StateMachineChecker.suspendHere()
+    }
+
+    builder {
+        r()
+    }
+    StateMachineChecker.check(numberOfSuspensions = 8)
+    return "OK"
+}
--- a/compiler/testData/codegen/bytecodeListing/coroutineFields.txt
+++ b/compiler/testData/codegen/bytecodeListing/coroutineFields.txt
@@ -5,7 +5,7 @@
     synthetic field exception: java.lang.Throwable
     synthetic final field this$0: Controller
     inner class Controller$multipleSuspensions$1
-    method <init>(p0: Controller, p1: COROUTINES_PACKAGE.Continuation): void
+    method <init>(p0: Controller, p1: kotlin.coroutines.experimental.Continuation): void
     public final @org.jetbrains.annotations.Nullable method doResume(@org.jetbrains.annotations.Nullable p0: java.lang.Object, @org.jetbrains.annotations.Nullable p1: java.lang.Throwable): java.lang.Object
     synthetic final method getLabel(): int
     synthetic final method setLabel(p0: int): void
@@ -18,7 +18,7 @@
     synthetic field exception: java.lang.Throwable
     synthetic final field this$0: Controller
     inner class Controller$nonTailCall$1
-    method <init>(p0: Controller, p1: COROUTINES_PACKAGE.Continuation): void
+    method <init>(p0: Controller, p1: kotlin.coroutines.experimental.Continuation): void
     public final @org.jetbrains.annotations.Nullable method doResume(@org.jetbrains.annotations.Nullable p0: java.lang.Object, @org.jetbrains.annotations.Nullable p1: java.lang.Throwable): java.lang.Object
     synthetic final method getLabel(): int
     synthetic final method setLabel(p0: int): void
@@ -29,10 +29,10 @@
     inner class Controller$multipleSuspensions$1
     inner class Controller$nonTailCall$1
     public method <init>(): void
-    public final @org.jetbrains.annotations.Nullable method multipleSuspensions(@org.jetbrains.annotations.NotNull p0: COROUTINES_PACKAGE.Continuation): java.lang.Object
-    public final @org.jetbrains.annotations.Nullable method nonTailCall(@org.jetbrains.annotations.NotNull p0: COROUTINES_PACKAGE.Continuation): java.lang.Object
-    public final @org.jetbrains.annotations.Nullable method suspendHere(@org.jetbrains.annotations.NotNull p0: COROUTINES_PACKAGE.Continuation): java.lang.Object
-    public final @org.jetbrains.annotations.Nullable method tailCall(@org.jetbrains.annotations.NotNull p0: COROUTINES_PACKAGE.Continuation): java.lang.Object
+    public final @org.jetbrains.annotations.Nullable method multipleSuspensions(@org.jetbrains.annotations.NotNull p0: kotlin.coroutines.experimental.Continuation): java.lang.Object
+    public final @org.jetbrains.annotations.Nullable method nonTailCall(@org.jetbrains.annotations.NotNull p0: kotlin.coroutines.experimental.Continuation): java.lang.Object
+    public final @org.jetbrains.annotations.Nullable method suspendHere(@org.jetbrains.annotations.NotNull p0: kotlin.coroutines.experimental.Continuation): java.lang.Object
+    public final @org.jetbrains.annotations.Nullable method tailCall(@org.jetbrains.annotations.NotNull p0: kotlin.coroutines.experimental.Continuation): java.lang.Object
 }
 
 @kotlin.Metadata
@@ -43,8 +43,8 @@
     field L$1: java.lang.Object
     private field p$: Controller
     inner class CoroutineFieldsKt$box$1
-    method <init>(p0: kotlin.jvm.internal.Ref$ObjectRef, p1: COROUTINES_PACKAGE.Continuation): void
-    public final @org.jetbrains.annotations.NotNull method create(@org.jetbrains.annotations.Nullable p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: COROUTINES_PACKAGE.Continuation): COROUTINES_PACKAGE.Continuation
+    method <init>(p0: kotlin.jvm.internal.Ref$ObjectRef, p1: kotlin.coroutines.experimental.Continuation): void
+    public final @org.jetbrains.annotations.NotNull method create(@org.jetbrains.annotations.Nullable p0: java.lang.Object, @org.jetbrains.annotations.NotNull p1: kotlin.coroutines.experimental.Continuation): kotlin.coroutines.experimental.Continuation
     public final @org.jetbrains.annotations.Nullable method doResume(@org.jetbrains.annotations.Nullable p0: java.lang.Object, @org.jetbrains.annotations.Nullable p1: java.lang.Throwable): java.lang.Object
     public final method invoke(p0: java.lang.Object, p1: java.lang.Object): java.lang.Object
 }
--- a/compiler/testData/codegen/bytecodeText/boxing/crossinlineSuspend.kt
+++ b/compiler/testData/codegen/bytecodeText/boxing/crossinlineSuspend.kt
@@ -6,5 +6,8 @@
     return i
 }
 
+// invokeSuspend$$forInline : valueOf
+// invokeSuspend : boxInt
+
 // 1 valueOf
-// 0 boxInt
+// 1 boxInt
--- a/compiler/testData/codegen/bytecodeText/coroutines/stateMachine/withTypeParameter.kt
+++ b/compiler/testData/codegen/bytecodeText/coroutines/stateMachine/withTypeParameter.kt
@@ -21,4 +21,6 @@
     }
 }
 
-// 4 TABLESWITCH
\ No newline at end of file
+// suspend lambdas: 4
+// suspend lambdas $$forInline: 1
+// 5 TABLESWITCH
\ No newline at end of file
--- a/compiler/testData/compileKotlinAgainstCustomBinaries/suspensionPointInMonitor/library/a.kt
+++ b/compiler/testData/compileKotlinAgainstCustomBinaries/suspensionPointInMonitor/library/a.kt
@@ -14,13 +14,4 @@
             b()
         }
     }
-}
-
-inline fun withCrossinline(crossinline a: suspend () -> Unit): suspend () -> Unit {
-    val c : suspend () -> Unit = {
-        inlineMe {
-            a()
-        }
-    }
-    return c
 }
\ No newline at end of file
--- a/compiler/testData/compileKotlinAgainstCustomBinaries/suspensionPointInMonitor/output.txt
+++ b/compiler/testData/compileKotlinAgainstCustomBinaries/suspensionPointInMonitor/output.txt
@@ -4,7 +4,10 @@
 compiler/testData/compileKotlinAgainstCustomBinaries/suspensionPointInMonitor/source.kt:14:13: error: a suspension point at SourceKt$test$2.invokeSuspend(source.kt:17) is inside a critical section
     builder {
             ^
-compiler/testData/compileKotlinAgainstCustomBinaries/suspensionPointInMonitor/source.kt:24:25: error: a suspension point at SourceKt$test$3$invokeSuspend$$inlined$withCrossinline$2.invokeSuspend(a.kt:31) is inside a critical section
+compiler/testData/compileKotlinAgainstCustomBinaries/suspensionPointInMonitor/source.kt:24:25: error: a suspension point at SourceKt$test$3$invokeSuspend$$inlined$withCrossinline$2.invokeSuspend(source.kt:62) is inside a critical section
         withCrossinline {
                         ^
+compiler/testData/compileKotlinAgainstCustomBinaries/suspensionPointInMonitor/source.kt:50:34: error: a suspension point at SourceKt$withCrossinline$c$1.invokeSuspend(source.kt:52) is inside a critical section
+    val c : suspend () -> Unit = {
+                                 ^
 COMPILATION_ERROR
--- a/compiler/testData/compileKotlinAgainstCustomBinaries/suspensionPointInMonitor/source.kt
+++ b/compiler/testData/compileKotlinAgainstCustomBinaries/suspensionPointInMonitor/source.kt
@@ -44,3 +44,13 @@
 interface SuspendRunnable {
     suspend fun run()
 }
+
+
+inline fun withCrossinline(crossinline a: suspend () -> Unit): suspend () -> Unit {
+    val c : suspend () -> Unit = {
+        inlineMe {
+            a()
+        }
+    }
+    return c
+}
--- a/compiler/tests/org/jetbrains/kotlin/codegen/BlackBoxCodegenTestGenerated.java
+++ b/compiler/tests/org/jetbrains/kotlin/codegen/BlackBoxCodegenTestGenerated.java
@@ -7303,6 +7303,63 @@
             }
         }
 
+        @TestMetadata("compiler/testData/codegen/box/coroutines/javaInterop")
+        @TestDataPath("$PROJECT_ROOT")
+        @RunWith(JUnit3RunnerWithInners.class)
+        public static class JavaInterop extends AbstractBlackBoxCodegenTest {
+            private void runTest(String testDataFilePath) throws Exception {
+                KotlinTestUtils.runTest(this::doTest, TargetBackend.JVM, testDataFilePath);
+            }
+
+            private void runTestWithPackageReplacement(String testDataFilePath, String packageName) throws Exception {
+                KotlinTestUtils.runTest(filePath -> doTestWithCoroutinesPackageReplacement(filePath, packageName), TargetBackend.JVM, testDataFilePath);
+            }
+
+            public void testAllFilesPresentInJavaInterop() throws Exception {
+                KotlinTestUtils.assertAllTestsPresentByMetadata(this.getClass(), new File("compiler/testData/codegen/box/coroutines/javaInterop"), Pattern.compile("^(.+)\\.kt$"), TargetBackend.JVM, true);
+            }
+
+            @TestMetadata("objectWithSeveralSuspends.kt")
+            public void testObjectWithSeveralSuspends_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/objectWithSeveralSuspends.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("objectWithSeveralSuspends.kt")
+            public void testObjectWithSeveralSuspends_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/objectWithSeveralSuspends.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("returnLambda.kt")
+            public void testReturnLambda_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/returnLambda.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("returnLambda.kt")
+            public void testReturnLambda_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/returnLambda.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("returnObject.kt")
+            public void testReturnObject_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/returnObject.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("returnObject.kt")
+            public void testReturnObject_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/returnObject.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("severalCaptures.kt")
+            public void testSeveralCaptures_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/severalCaptures.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("severalCaptures.kt")
+            public void testSeveralCaptures_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/severalCaptures.kt", "kotlin.coroutines");
+            }
+        }
+
         @TestMetadata("compiler/testData/codegen/box/coroutines/localFunctions")
         @TestDataPath("$PROJECT_ROOT")
         @RunWith(JUnit3RunnerWithInners.class)
--- a/compiler/tests/org/jetbrains/kotlin/codegen/BlackBoxInlineCodegenTestGenerated.java
+++ b/compiler/tests/org/jetbrains/kotlin/codegen/BlackBoxInlineCodegenTestGenerated.java
@@ -3545,6 +3545,16 @@
             runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/multipleSuspensionPoints.kt", "kotlin.coroutines");
         }
 
+        @TestMetadata("nonSuspendCrossinline.kt")
+        public void testNonSuspendCrossinline_1_2() throws Exception {
+            runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/nonSuspendCrossinline.kt", "kotlin.coroutines.experimental");
+        }
+
+        @TestMetadata("nonSuspendCrossinline.kt")
+        public void testNonSuspendCrossinline_1_3() throws Exception {
+            runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/nonSuspendCrossinline.kt", "kotlin.coroutines");
+        }
+
         @TestMetadata("returnValue.kt")
         public void testReturnValue_1_2() throws Exception {
             runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/returnValue.kt", "kotlin.coroutines.experimental");
@@ -3766,6 +3776,26 @@
                 KotlinTestUtils.assertAllTestsPresentByMetadata(this.getClass(), new File("compiler/testData/codegen/boxInline/suspend/stateMachine"), Pattern.compile("^(.+)\\.kt$"), TargetBackend.ANY, true);
             }
 
+            @TestMetadata("crossingCoroutineBoundaries.kt")
+            public void testCrossingCoroutineBoundaries_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/crossingCoroutineBoundaries.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("crossingCoroutineBoundaries.kt")
+            public void testCrossingCoroutineBoundaries_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/crossingCoroutineBoundaries.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("independentInline.kt")
+            public void testIndependentInline_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/independentInline.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("independentInline.kt")
+            public void testIndependentInline_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/independentInline.kt", "kotlin.coroutines");
+            }
+
             @TestMetadata("innerLambdaInsideLambda.kt")
             public void testInnerLambdaInsideLambda_1_2() throws Exception {
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerLambdaInsideLambda.kt", "kotlin.coroutines.experimental");
@@ -3826,6 +3856,16 @@
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectInsideInnerObject.kt", "kotlin.coroutines");
             }
 
+            @TestMetadata("innerObjectRetransformation.kt")
+            public void testInnerObjectRetransformation_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectRetransformation.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("innerObjectRetransformation.kt")
+            public void testInnerObjectRetransformation_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectRetransformation.kt", "kotlin.coroutines");
+            }
+
             @TestMetadata("innerObjectSeveralFunctions.kt")
             public void testInnerObjectSeveralFunctions_1_2() throws Exception {
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectSeveralFunctions.kt", "kotlin.coroutines.experimental");
@@ -3856,6 +3896,16 @@
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObject.kt", "kotlin.coroutines");
             }
 
+            @TestMetadata("insideObject.kt")
+            public void testInsideObject_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/insideObject.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("insideObject.kt")
+            public void testInsideObject_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/insideObject.kt", "kotlin.coroutines");
+            }
+
             @TestMetadata("normalInline.kt")
             public void testNormalInline_1_2() throws Exception {
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/normalInline.kt", "kotlin.coroutines.experimental");
@@ -3875,6 +3925,56 @@
             public void testNumberOfSuspentions_1_3() throws Exception {
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/numberOfSuspentions.kt", "kotlin.coroutines");
             }
+
+            @TestMetadata("objectInsideLambdas.kt")
+            public void testObjectInsideLambdas_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/objectInsideLambdas.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("objectInsideLambdas.kt")
+            public void testObjectInsideLambdas_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/objectInsideLambdas.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("oneInlineTwoCaptures.kt")
+            public void testOneInlineTwoCaptures_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/oneInlineTwoCaptures.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("oneInlineTwoCaptures.kt")
+            public void testOneInlineTwoCaptures_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/oneInlineTwoCaptures.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("passLambda.kt")
+            public void testPassLambda_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passLambda.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("passLambda.kt")
+            public void testPassLambda_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passLambda.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("passParameterLambda.kt")
+            public void testPassParameterLambda_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passParameterLambda.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("passParameterLambda.kt")
+            public void testPassParameterLambda_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passParameterLambda.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("passParameter.kt")
+            public void testPassParameter_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passParameter.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("passParameter.kt")
+            public void testPassParameter_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passParameter.kt", "kotlin.coroutines");
+            }
         }
     }
 
--- a/compiler/tests/org/jetbrains/kotlin/codegen/CompileKotlinAgainstInlineKotlinTestGenerated.java
+++ b/compiler/tests/org/jetbrains/kotlin/codegen/CompileKotlinAgainstInlineKotlinTestGenerated.java
@@ -3545,6 +3545,16 @@
             runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/multipleSuspensionPoints.kt", "kotlin.coroutines");
         }
 
+        @TestMetadata("nonSuspendCrossinline.kt")
+        public void testNonSuspendCrossinline_1_2() throws Exception {
+            runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/nonSuspendCrossinline.kt", "kotlin.coroutines.experimental");
+        }
+
+        @TestMetadata("nonSuspendCrossinline.kt")
+        public void testNonSuspendCrossinline_1_3() throws Exception {
+            runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/nonSuspendCrossinline.kt", "kotlin.coroutines");
+        }
+
         @TestMetadata("returnValue.kt")
         public void testReturnValue_1_2() throws Exception {
             runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/returnValue.kt", "kotlin.coroutines.experimental");
@@ -3766,6 +3776,26 @@
                 KotlinTestUtils.assertAllTestsPresentByMetadata(this.getClass(), new File("compiler/testData/codegen/boxInline/suspend/stateMachine"), Pattern.compile("^(.+)\\.kt$"), TargetBackend.ANY, true);
             }
 
+            @TestMetadata("crossingCoroutineBoundaries.kt")
+            public void testCrossingCoroutineBoundaries_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/crossingCoroutineBoundaries.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("crossingCoroutineBoundaries.kt")
+            public void testCrossingCoroutineBoundaries_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/crossingCoroutineBoundaries.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("independentInline.kt")
+            public void testIndependentInline_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/independentInline.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("independentInline.kt")
+            public void testIndependentInline_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/independentInline.kt", "kotlin.coroutines");
+            }
+
             @TestMetadata("innerLambdaInsideLambda.kt")
             public void testInnerLambdaInsideLambda_1_2() throws Exception {
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerLambdaInsideLambda.kt", "kotlin.coroutines.experimental");
@@ -3826,6 +3856,16 @@
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectInsideInnerObject.kt", "kotlin.coroutines");
             }
 
+            @TestMetadata("innerObjectRetransformation.kt")
+            public void testInnerObjectRetransformation_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectRetransformation.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("innerObjectRetransformation.kt")
+            public void testInnerObjectRetransformation_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectRetransformation.kt", "kotlin.coroutines");
+            }
+
             @TestMetadata("innerObjectSeveralFunctions.kt")
             public void testInnerObjectSeveralFunctions_1_2() throws Exception {
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectSeveralFunctions.kt", "kotlin.coroutines.experimental");
@@ -3856,6 +3896,16 @@
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObject.kt", "kotlin.coroutines");
             }
 
+            @TestMetadata("insideObject.kt")
+            public void testInsideObject_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/insideObject.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("insideObject.kt")
+            public void testInsideObject_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/insideObject.kt", "kotlin.coroutines");
+            }
+
             @TestMetadata("normalInline.kt")
             public void testNormalInline_1_2() throws Exception {
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/normalInline.kt", "kotlin.coroutines.experimental");
@@ -3875,6 +3925,56 @@
             public void testNumberOfSuspentions_1_3() throws Exception {
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/numberOfSuspentions.kt", "kotlin.coroutines");
             }
+
+            @TestMetadata("objectInsideLambdas.kt")
+            public void testObjectInsideLambdas_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/objectInsideLambdas.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("objectInsideLambdas.kt")
+            public void testObjectInsideLambdas_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/objectInsideLambdas.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("oneInlineTwoCaptures.kt")
+            public void testOneInlineTwoCaptures_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/oneInlineTwoCaptures.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("oneInlineTwoCaptures.kt")
+            public void testOneInlineTwoCaptures_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/oneInlineTwoCaptures.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("passLambda.kt")
+            public void testPassLambda_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passLambda.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("passLambda.kt")
+            public void testPassLambda_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passLambda.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("passParameterLambda.kt")
+            public void testPassParameterLambda_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passParameterLambda.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("passParameterLambda.kt")
+            public void testPassParameterLambda_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passParameterLambda.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("passParameter.kt")
+            public void testPassParameter_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passParameter.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("passParameter.kt")
+            public void testPassParameter_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passParameter.kt", "kotlin.coroutines");
+            }
         }
     }
 
--- a/compiler/tests/org/jetbrains/kotlin/codegen/LightAnalysisModeTestGenerated.java
+++ b/compiler/tests/org/jetbrains/kotlin/codegen/LightAnalysisModeTestGenerated.java
@@ -7303,6 +7303,63 @@
             }
         }
 
+        @TestMetadata("compiler/testData/codegen/box/coroutines/javaInterop")
+        @TestDataPath("$PROJECT_ROOT")
+        @RunWith(JUnit3RunnerWithInners.class)
+        public static class JavaInterop extends AbstractLightAnalysisModeTest {
+            private void runTest(String testDataFilePath) throws Exception {
+                KotlinTestUtils.runTest(this::doTest, TargetBackend.JVM, testDataFilePath);
+            }
+
+            private void runTestWithPackageReplacement(String testDataFilePath, String packageName) throws Exception {
+                KotlinTestUtils.runTest(filePath -> doTestWithCoroutinesPackageReplacement(filePath, packageName), TargetBackend.JVM, testDataFilePath);
+            }
+
+            public void testAllFilesPresentInJavaInterop() throws Exception {
+                KotlinTestUtils.assertAllTestsPresentByMetadata(this.getClass(), new File("compiler/testData/codegen/box/coroutines/javaInterop"), Pattern.compile("^(.+)\\.kt$"), TargetBackend.JVM, true);
+            }
+
+            @TestMetadata("objectWithSeveralSuspends.kt")
+            public void testObjectWithSeveralSuspends_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/objectWithSeveralSuspends.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("objectWithSeveralSuspends.kt")
+            public void testObjectWithSeveralSuspends_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/objectWithSeveralSuspends.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("returnLambda.kt")
+            public void testReturnLambda_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/returnLambda.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("returnLambda.kt")
+            public void testReturnLambda_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/returnLambda.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("returnObject.kt")
+            public void testReturnObject_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/returnObject.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("returnObject.kt")
+            public void testReturnObject_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/returnObject.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("severalCaptures.kt")
+            public void testSeveralCaptures_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/severalCaptures.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("severalCaptures.kt")
+            public void testSeveralCaptures_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/severalCaptures.kt", "kotlin.coroutines");
+            }
+        }
+
         @TestMetadata("compiler/testData/codegen/box/coroutines/localFunctions")
         @TestDataPath("$PROJECT_ROOT")
         @RunWith(JUnit3RunnerWithInners.class)
--- a/compiler/tests/org/jetbrains/kotlin/codegen/ir/IrBlackBoxCodegenTestGenerated.java
+++ b/compiler/tests/org/jetbrains/kotlin/codegen/ir/IrBlackBoxCodegenTestGenerated.java
@@ -7303,6 +7303,63 @@
             }
         }
 
+        @TestMetadata("compiler/testData/codegen/box/coroutines/javaInterop")
+        @TestDataPath("$PROJECT_ROOT")
+        @RunWith(JUnit3RunnerWithInners.class)
+        public static class JavaInterop extends AbstractIrBlackBoxCodegenTest {
+            private void runTest(String testDataFilePath) throws Exception {
+                KotlinTestUtils.runTest(this::doTest, TargetBackend.JVM_IR, testDataFilePath);
+            }
+
+            private void runTestWithPackageReplacement(String testDataFilePath, String packageName) throws Exception {
+                KotlinTestUtils.runTest(filePath -> doTestWithCoroutinesPackageReplacement(filePath, packageName), TargetBackend.JVM_IR, testDataFilePath);
+            }
+
+            public void testAllFilesPresentInJavaInterop() throws Exception {
+                KotlinTestUtils.assertAllTestsPresentByMetadata(this.getClass(), new File("compiler/testData/codegen/box/coroutines/javaInterop"), Pattern.compile("^(.+)\\.kt$"), TargetBackend.JVM_IR, true);
+            }
+
+            @TestMetadata("objectWithSeveralSuspends.kt")
+            public void testObjectWithSeveralSuspends_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/objectWithSeveralSuspends.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("objectWithSeveralSuspends.kt")
+            public void testObjectWithSeveralSuspends_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/objectWithSeveralSuspends.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("returnLambda.kt")
+            public void testReturnLambda_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/returnLambda.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("returnLambda.kt")
+            public void testReturnLambda_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/returnLambda.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("returnObject.kt")
+            public void testReturnObject_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/returnObject.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("returnObject.kt")
+            public void testReturnObject_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/returnObject.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("severalCaptures.kt")
+            public void testSeveralCaptures_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/severalCaptures.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("severalCaptures.kt")
+            public void testSeveralCaptures_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/box/coroutines/javaInterop/severalCaptures.kt", "kotlin.coroutines");
+            }
+        }
+
         @TestMetadata("compiler/testData/codegen/box/coroutines/localFunctions")
         @TestDataPath("$PROJECT_ROOT")
         @RunWith(JUnit3RunnerWithInners.class)
--- a/compiler/tests/org/jetbrains/kotlin/codegen/ir/IrBlackBoxInlineCodegenTestGenerated.java
+++ b/compiler/tests/org/jetbrains/kotlin/codegen/ir/IrBlackBoxInlineCodegenTestGenerated.java
@@ -3545,6 +3545,16 @@
             runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/multipleSuspensionPoints.kt", "kotlin.coroutines");
         }
 
+        @TestMetadata("nonSuspendCrossinline.kt")
+        public void testNonSuspendCrossinline_1_2() throws Exception {
+            runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/nonSuspendCrossinline.kt", "kotlin.coroutines.experimental");
+        }
+
+        @TestMetadata("nonSuspendCrossinline.kt")
+        public void testNonSuspendCrossinline_1_3() throws Exception {
+            runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/nonSuspendCrossinline.kt", "kotlin.coroutines");
+        }
+
         @TestMetadata("returnValue.kt")
         public void testReturnValue_1_2() throws Exception {
             runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/returnValue.kt", "kotlin.coroutines.experimental");
@@ -3766,6 +3776,26 @@
                 KotlinTestUtils.assertAllTestsPresentByMetadata(this.getClass(), new File("compiler/testData/codegen/boxInline/suspend/stateMachine"), Pattern.compile("^(.+)\\.kt$"), TargetBackend.JVM_IR, true);
             }
 
+            @TestMetadata("crossingCoroutineBoundaries.kt")
+            public void testCrossingCoroutineBoundaries_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/crossingCoroutineBoundaries.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("crossingCoroutineBoundaries.kt")
+            public void testCrossingCoroutineBoundaries_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/crossingCoroutineBoundaries.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("independentInline.kt")
+            public void testIndependentInline_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/independentInline.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("independentInline.kt")
+            public void testIndependentInline_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/independentInline.kt", "kotlin.coroutines");
+            }
+
             @TestMetadata("innerLambdaInsideLambda.kt")
             public void testInnerLambdaInsideLambda_1_2() throws Exception {
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerLambdaInsideLambda.kt", "kotlin.coroutines.experimental");
@@ -3826,6 +3856,16 @@
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectInsideInnerObject.kt", "kotlin.coroutines");
             }
 
+            @TestMetadata("innerObjectRetransformation.kt")
+            public void testInnerObjectRetransformation_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectRetransformation.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("innerObjectRetransformation.kt")
+            public void testInnerObjectRetransformation_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectRetransformation.kt", "kotlin.coroutines");
+            }
+
             @TestMetadata("innerObjectSeveralFunctions.kt")
             public void testInnerObjectSeveralFunctions_1_2() throws Exception {
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObjectSeveralFunctions.kt", "kotlin.coroutines.experimental");
@@ -3856,6 +3896,16 @@
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/innerObject.kt", "kotlin.coroutines");
             }
 
+            @TestMetadata("insideObject.kt")
+            public void testInsideObject_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/insideObject.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("insideObject.kt")
+            public void testInsideObject_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/insideObject.kt", "kotlin.coroutines");
+            }
+
             @TestMetadata("normalInline.kt")
             public void testNormalInline_1_2() throws Exception {
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/normalInline.kt", "kotlin.coroutines.experimental");
@@ -3875,6 +3925,56 @@
             public void testNumberOfSuspentions_1_3() throws Exception {
                 runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/numberOfSuspentions.kt", "kotlin.coroutines");
             }
+
+            @TestMetadata("objectInsideLambdas.kt")
+            public void testObjectInsideLambdas_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/objectInsideLambdas.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("objectInsideLambdas.kt")
+            public void testObjectInsideLambdas_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/objectInsideLambdas.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("oneInlineTwoCaptures.kt")
+            public void testOneInlineTwoCaptures_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/oneInlineTwoCaptures.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("oneInlineTwoCaptures.kt")
+            public void testOneInlineTwoCaptures_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/oneInlineTwoCaptures.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("passLambda.kt")
+            public void testPassLambda_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passLambda.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("passLambda.kt")
+            public void testPassLambda_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passLambda.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("passParameterLambda.kt")
+            public void testPassParameterLambda_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passParameterLambda.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("passParameterLambda.kt")
+            public void testPassParameterLambda_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passParameterLambda.kt", "kotlin.coroutines");
+            }
+
+            @TestMetadata("passParameter.kt")
+            public void testPassParameter_1_2() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passParameter.kt", "kotlin.coroutines.experimental");
+            }
+
+            @TestMetadata("passParameter.kt")
+            public void testPassParameter_1_3() throws Exception {
+                runTestWithPackageReplacement("compiler/testData/codegen/boxInline/suspend/stateMachine/passParameter.kt", "kotlin.coroutines");
+            }
         }
     }
 
--- a/compiler/tests-common/tests/org/jetbrains/kotlin/coroutineTestUtil.kt
+++ b/compiler/tests-common/tests/org/jetbrains/kotlin/coroutineTestUtil.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
+ * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
  * that can be found in the license/LICENSE.txt file.
  */
 
@@ -77,12 +77,18 @@
             ""
 
     val checkStateMachineString = """
-    object StateMachineChecker {
+    class StateMachineCheckerClass {
         private var counter = 0
         var finished = false
 
         var proceed: () -> Unit = {}
 
+        fun reset() {
+            counter = 0
+            finished = false
+            proceed = {}
+        }
+
         suspend fun suspendHere() = suspendCoroutine<Unit> { c ->
             counter++
             proceed = { c.resume(Unit) }
@@ -100,6 +106,7 @@
             if (!finished) error("Wrong state-machine generated: it is not finished yet")
         }
     }
+    val StateMachineChecker = StateMachineCheckerClass()
     object CheckStateMachineContinuation: ContinuationAdapter<Unit>() {
         override val context: CoroutineContext
             get() = EmptyCoroutineContext
